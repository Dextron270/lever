# This grammar has been obtained from the following link:
# https://www.lysator.liu.se/c/ANSI-C-grammar-y.html
# it has been translated to Lever's grammar notation.

# This grammar is ambiguous, and the ambiguity is resolved
# when the parse tree is traversed.

# Many .grammar files in lever are used such that
# they parse the whole file in one go. 
translation_unit =>
    first { external_declaration }
    append { translation_unit external_declaration }

# Though this is likely used more often, because it's fun to
# 'stream' C code, declaration by declaration.
external_declaration =>
    declaration

declaration =>
    declaration_declarator_init ";"
    # declaration_specifiers ";"      # This is bit weird, but was in the ANSI grammar.
                                      # It appears there's a bug in chartparser,
                                      # It does not recognize ambiguity here.
                                      # but I didn't figure its location yet.

    struct_or_union_specifier ";"     # use of it appeared on stream, so lets try
                                      # avoid it for a moment.
    enum_specifier ";"

# The error seem to occur when I have rule: X Y | X, and the
# first can consume latter.
# How deep it is in the chart doesn't seem to matter.

# Constructing an ambiguous grammar to test.


# The prefix in the C syntax that specifies the type and
# storage for variable.
declaration_specifiers =>
    set_storage_class_specifier { specifier{}            storage_class_specifier }
    set_storage_class_specifier { declaration_specifiers storage_class_specifier }
    add_type_specifier { specifier{}            type_specifier }
    add_type_specifier { declaration_specifiers type_specifier }
    add_type_qualifier { specifier{}            type_qualifier }
    add_type_qualifier { declaration_specifiers type_qualifier }


# The declarations lay out like onions above the specifier.
# Described this way, the LR-parser can manhandle 'typedef'
declaration_declarator =>
    declaration { declaration_specifiers declarator }
    declaration { declaration_declarator_init "," declarator }

# The really finicky and little-known detail about C is that
# new variable declarations can cover typedef aliases.
# It takes effect immediately after. That is the initializer
# of declarator takes the variable in declarator as variable.
# Although in 'typedef' initializer is disallowed.
declaration_declarator_init =>
    declaration_declarator
    initializer { declaration_declarator "=" initializer }

# Declarators appear widespread. They also 'stack' over each
# other. The return value of function declarator stacks over it.
declarator =>
    direct_declarator
    pointer_declarator { pointer direct_declarator }

direct_declarator =>
    declarator { @identifier }
    "(" declarator ")"
    array_declarator { direct_declarator '[' constant_expression ']' }
    array_declarator { direct_declarator '[' nil{}               ']' }
    function_declarator { direct_declarator '(' parameter_type_list ')' }
    function_declarator { direct_declarator '(' identifier_list     ')' }
    function_declarator { direct_declarator '(' list{}              ')' }

pointer =>
    first  { '*' list{}                      }
    first  { '*' type_qualifier_list         }
    append { '*' list{}              pointer }
    append { '*' type_qualifier_list pointer }

type_qualifier_list =>
    first  { type_qualifier }
    append { type_qualifier_list type_qualifier }

# parameter_type_list appears in function declarator and definition.
parameter_type_list =>
    parameter_list
    va_args { parameter_list ',' "..." }

parameter_list =>
    first  { parameter_declaration }
    append { parameter_list ',' parameter_declaration }

parameter_declaration =>
    parameter_declaration_hack # Without this, the hairy
                               # ends up bulldozed by an append.

parameter_declaration_hack =>
    parameter { declaration_specifiers declarator }
    parameter { declaration_specifiers abstract_declarator }
    declaration_specifiers

identifier_list =>
    first  { as_name { @identifier } }
    append { identifier_list ',' as_name { @identifier } }

# The abstract declarator means for declarations without a
# name. They happen often when you pass pointers as
# arguments and don't bother to name them.
abstract_declarator =>
    pointer
    direct_abstract_declarator
    pointer direct_abstract_declarator

direct_abstract_declarator =>
    '(' abstract_declarator ')'
    '[' ']'
    '[' constant_expression ']'
    direct_abstract_declarator '[' ']'
    direct_abstract_declarator '[' constant_expression ']'
    '(' ')'
    '(' parameter_type_list ')'
    direct_abstract_declarator '(' ')'
    direct_abstract_declarator '(' parameter_type_list ')'

# When you want to initialize a variable while you define
# it, you make an initializer.
initializer =>
    assignment_expression
    '{' initializer_list '}'
    '{' initializer_list ',' '}'

initializer_list =>
    initializer
    initializer_list "," initializer

# as_type is used to resolve ambiguity here. Roughly, on
# ambiguity point we visit both branches and discard the
# ones that hit as_type or as_name for wrong variables.

type_specifier =>
    as_type { @identifier }
    primitive_type { type_specifier_kw }

storage_class_specifier => ["typedef", "extern", "static",
                            "auto", "register"]
type_specifier_kw => ["void", "char", "short", "int", "long",
                      "float", "double", "signed", "unsigned"]
type_qualifier => ["const", "volatile"]


# 'struct', 'enum', 'union' gets described here.
type_specifier =>
    struct_or_union_specifier
    enum_specifier

# Note that identifier isn't checked here. On LR parser, if
# it is after these three keywords, you should keep it as-it!
# Remember that all declaration list can have ambiguity..
struct_or_union_specifier =>
    data_specifier { struct_or_union @identifier "{" struct_declaration_list "}" }
    data_specifier { struct_or_union nil{}       "{" struct_declaration_list "}" }
    data_specifier { struct_or_union @identifier     list{} }

struct_or_union => ["struct", "union"]

struct_declaration_list =>
    first  { struct_declaration }
    append { struct_declaration_list struct_declaration }

struct_declaration =>
    specifier_qualifier_list struct_declarator_list ';'

specifier_qualifier_list =>
    add_type_specifier { specifier{}            type_specifier }
    add_type_specifier { declaration_specifiers type_specifier }
    add_type_qualifier { specifier{}            type_qualifier }
    add_type_qualifier { declaration_specifiers type_qualifier }

struct_declarator_list =>
    first  { struct_declarator }
    append { struct_declarator_list ',' struct_declarator }

struct_declarator =>
    declarator
    bitfield { nil{}      ':' constant_expression }
    bitfield { declarator ':' constant_expression }

enum_specifier =>
    enum_specifier { "enum" nil{}       "{" enumerator_list "}" }
    enum_specifier { "enum" @identifier "{" enumerator_list "}" }
    enum_specifier { "enum" @identifier     list{} }

enumerator_list =>
    first  { enumerator }
    append { enumerator_list ',' enumerator }

enumerator =>
    enumerator { @identifier     nil{} }
    enumerator { @identifier '=' constant_expression }


# external_declaration =>
#    function_definition   #  whoever uses this first time
#                          #  adjust to your needs.
#
#function_definition =>
#    function { declaration_specifiers declarator declaration_list compound_statement }
#    function { nil{}                  declarator declaration_list compound_statement }
#    function { declaration_specifiers declarator nil{}            compound_statement }
#    function { nil{}                  declarator nil{}            compound_statement }
#
## Declarations appear with "declaration" semantic label.
## Details in the declaration list can come ambiguous, so
## this tends to be wrapped with a function to pass type details
## in and resolve ambiguity.
#declaration_list =>
#    first  { declaration }
#    append { declaration_list declaration }

#compound_statement =>
#    '{' '}'
#    '{' statement_list '}'
#    '{' declaration_list '}'
#    '{' declaration_list statement_list '}'
#
#statement =>
#    labeled_statement
#    compound_statement
#    expression_statement
#    selection_statement
#    iteration_statement
#    jump_statement
#
#labeled_statement =>
#    @identifier ":" statement
#    "case" constant_expression ":" statement
#    "default" ":" statement
#
#statement_list =>
#    first  { statement }
#    append { statement_list statement }
#
#expression_statement =>
#    ";"
#    expression ';'
#
#selection_statement =>
#    "if" "(" expression ")" statement
#    "if" "(" expression ")" statement "else" statement
#    "switch" "(" expression ")" statement
#
#iteration_statement =>
#    "while" "(" expression ")" statement
#    "do" statement "while" "(" expression ")" ";"
#    "for" "(" expression_statement expression_statement ")" statement
#    "for" "(" expression_statement expression_statement expression ")" statement
#
#jump_statement =>
#    "goto" @identifier ";"
#    "continue" ";"
#    "break" ";"
#    "return" ";"
#    "return" expression ";"


expression =>
    assignment_expression
    expression ',' assignment_expression

assignment_expression =>
    conditional_expression
    unary_expression assignment_operator assignment_expression

assignment_operator => ['=', "*=", "/=", "%=", "+=", "-=",
                        "<<=", ">>=", "&=", "^=", "|="]

constant_expression => conditional_expression

conditional_expression =>
    logical_or_expression
    logical_or_expression '?' expression ':' conditional_expression

logical_or_expression =>
    logical_and_expression
    logical_or_expression "||" logical_and_expression

logical_and_expression =>
    inclusive_or_expression
    logical_and_expression "&&" inclusive_or_expression

inclusive_or_expression =>
    exclusive_or_expression
    inclusive_or_expression '|' exclusive_or_expression

exclusive_or_expression =>
    and_expression
    exclusive_or_expression '^' and_expression

and_expression =>
    equality_expression
    and_expression '&' equality_expression

equality_expression =>
    relational_expression
    equality_expression "==" relational_expression
    equality_expression "!=" relational_expression

relational_expression =>
    shift_expression
    relational_expression '<' shift_expression
    relational_expression '>' shift_expression
    relational_expression "<=" shift_expression
    relational_expression ">=" shift_expression

shift_expression =>
    additive_expression
    shift_expression "<<" additive_expression
    shift_expression ">>" additive_expression

additive_expression =>
    multiplicative_expression
    additive_expression '+' multiplicative_expression
    additive_expression '-' multiplicative_expression

multiplicative_expression =>
    cast_expression
    multiplicative_expression '*' cast_expression
    multiplicative_expression '/' cast_expression
    multiplicative_expression '%' cast_expression

cast_expression =>
    unary_expression
    '(' type_name_clause ')' cast_expression

unary_expression =>
    postfix_expression
    "++" unary_expression
    "--" unary_expression
    unary_operator cast_expression
    "sizeof" unary_expression
    "sizeof" '(' in_sizeof ')'

in_sizeof =>
    specifier_qualifier_list
    specifier_qualifier_list abstract_declarator

unary_operator => ["&", "*", "+", "-", "~", "!"]

postfix_expression =>
    primary_expression
    postfix_expression '[' expression ']'
    postfix_expression '(' ')'
    postfix_expression '(' argument_expression_list ')'
    postfix_expression '.' @identifier
    postfix_expression "->" @identifier
    postfix_expression "++"
    postfix_expression "--"

argument_expression_list =>
    first  { assignment_expression }
    append { argument_expression_list "," assignment_expression }

primary_expression =>
    as_name { @identifier }
    @number
    @string
    @char
    "(" expression ")"
