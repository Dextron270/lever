import c, chartparser, json
# Completion of this strategy is due to 0.9.0 milestone
# STRATEGY: Improve foreign function interface to extend it's capabilities.
#           Provide complete REPL+Integrated Editor suite for lever.
# 
# I want people to frown when they see lever FFI and then contempt their
# language do not have this kind of system. To do this it needs to be
# slightly better and get some more exposure.

# Powerful interactive programming is lever's staple feature. This means we
# need really powerfull integrated development environment embedded into the
# runtime. The first step would be to provide a REPL that does bit more than
# reading a line and printing another out.

# TACTIC: use readline via FFI
# motivation: 
#   Line-editing tools in console are a great way to prepare
#   for the needs of a real IDE early on. It is also a feature many
#   other dynamic language implementations lack.
#
# requirements:
#   Use of readline requires that callbacks are implemented,
#   It also requires that library variables are handled more like
#   ordinary memory entries, because readline relies on global variables.

#   Use of readline requires dynamic loading that interrupts if the
#   library isn't available.

#   Also we may want to use this feature async. Async readline that doesn't
#   get confused by printing lines out would be so
#   awesome that it gives a new meaning for awesome.

#   Use of readline requires good C header generation. The cffi-gen library
#   is clumsy to use and update. Partially my own fault because I relied on
#   LR parsing. 

#   I believe it'd be the time to implement cffi header generator in lever.

#   To do that we need a C parser. Wholly functioning C parser! With macro
#   preprocessor.

main = ():
    #stdio_h = "/usr/include/stdio.h"
    stdio_h = dir ++ "test.c"
    macro_env = c.std_macro_env()
    # This is actually something exposed to user. The user can select a config
    # The config comes from pytci's gcc_probe
    # Ran it with gcc_probe.py gcc -m32
    # and without the -m32
    config = json.read_file("/home/cheery/.local/cc-config-x86_64.json")

    # giving the preprocessor a stream allows you to stream
    # from elsewhere than files. Although this uses the include like usual.
    preprocessor = c.Preprocessor(config, macro_env, c.open_token_stream(stdio_h))
    parser = c.language.new_parser()
    parser.default_ambiguity_resolution = ambiguity
    keywords = c.language.table.keywords
    terminals = c.language.table.terminals

    actions = :exnihilo()
        function = (specifier, declarator, functypes, body):
            return (scope):
                spec = specifier(scope)
                declarator = declarator(scope)
                declarator.specifier = spec
                # Old style function definitions described argument types
                # below declaration. This style seems cleaner in some places,
                # although its use has been discouraged.
                ft = []
                for decl in functypes
                    ft.append(decl(scope))
                declarator.oldtypes = ft
                # Maybe they think that it's easy enough to extend the
                # declarator to multiple lines.
                stmts = []
                for stmt in body
                    stmts.append(stmt(scope))

                func = Function(declarator, stmts)
                scope.defs.append(func)
                return func

        declaration = (specifier, declarator):
            return (scope):
                spec_or_decl = specifier(scope)
                declarator = declarator(scope)
                declarator.specifier = spec_or_decl.specifier
                if spec_or_decl != spec_or_decl.specifier
                    declarator.last = spec_or_decl
                scope.declare(declarator)
                return declarator

        declarator = (identifier=null):
            return (scope):
                return Declarator(identifier)
        pointer_declarator = (ptr, base):
            return (scope):
                declarator = base(scope)
                declarator.stack = :exnihilo()
                    next = declarator.stack
                    type = "pointer"
                    ptr = ptr
                return declarator
        array_declarator = (base, const):
            return (scope):
                declarator = base(scope)
                declarator.stack = :exnihilo()
                    next = declarator.stack
                    type = "array"
                    if const
                        size = const(scope)
                    else
                        size = null
                return declarator
        function_declarator = (base, arglist):
            return (scope):
                declarator = base(scope)
                # The arglists contain spiders.
                args = []
                for arg in arglist
                    args.append(arg(scope)) # and spiders want out.
                declarator.stack = :exnihilo()
                    next = declarator.stack
                    type = "function"
                    args = args 
                return declarator
        parameter = (specifier, declarator):
            return (scope):
                spec_or_decl = specifier(scope)
                declarator = declarator(scope)
                declarator.specifier = spec_or_decl.specifier
                # This 'declarator' is also a declarator.
                # Note that even if parameter list is filled with
                # declarators, it may also contain specifiers.
                return declarator
        va_args = (parameters):
            fn = (scope):
                return "..."
            parameters.append(fn)
            return parameters

        specifier = ():
            return (scope):
                return Specifier()
        set_storage_class_specifier = (specifier, storage):
            return (scope):
                # Multiple storage classes is an error.
                # We don't check it yet.
                specifier = specifier(scope)
                specifier.storage = storage.value
                return specifier
        add_type_specifier = (specifier, type):
            return (scope):
                specifier = specifier(scope)
                specifier.typespec.append(type(scope))
                return specifier
        add_type_qualifier = (specifier, qualifier):
            return (scope):
                specifier = specifier(scope)
                specifier.qualifiers.add(qualifier.value)
                return specifier

        primitive_type = (identifier):
            return (scope):
                return identifier.value

        as_type = (identifier):
            return (scope):
                if not scope.is_type(identifier.value)
                    raise Conflict(identifier, "type")
                return Reference(identifier.value, scope.variables.get(identifier.value))

        as_name = (identifier):
            return (scope):
                if scope.is_type(identifier.value)
                    raise Conflict(identifier, "variable")
                return Reference(identifier.value, scope.variables.get(identifier.value))

        data_specifier = (which, name, fields):
            return (scope):
                flds = []
                for field in fields
                    specifier = field[0](scope)
                    for decl in field[1]
                        d = decl(scope)
                        d.specifier = specifier
                        flds.append(d)
                ds = DataSpecifier(which, name, flds)
                scope.tags.append(ds)
                return ds

        enum_specifier = (name, enums):
            return (scope):
                enum = EnumSpecifier(name)
                for f in enums
                    f(scope, enum)
                scope.tags.append(enum)
                return enum
        enumerator = (name, const):
            return (scope, enum):
                # Smearing of the enum is left to the application.
                # This is done because there is no certainty what the
                # user wants to do yet.
                if const
                    c = const(scope)
                else
                    c = null
                enum.enums.append([name, c])

        binary = (lhs, op, rhs):
            return (scope):
                return Binary(lhs(scope), op, rhs(scope))
        sizeof = (spec):
            return (scope):
                return Sizeof(scope, spec(scope))
        const = (value):
            return (scope):
                return Constant(value)
        nop = ():
            return (scope):
                return null

        nil = ():
            return null
        list = (args...):
            return args
        first = (a):
            return [a]
        append = (a, b):
            a.append(b)
            return a

    post = (rule, args, start, stop):
        res = rule.annotation(actions, args, [])
        # todo: add reference to start -token here?
        #print(rule, args, "->", res)
        return res


    scope = Scope()
    
    # hmm...
    scope.variables["__builtin_va_list"] = :exnihilo()
        type = "type"
        declarator = null

    toks = []
    while not preprocessor.empty
        token = preprocessor.step()
        if not token
            continue
        toks.append(token)
        if token.name == "identifier" and token.value in keywords
            term = terminals.get(keywords.get(token.value))
# ... interesting......
#        elif token.name == "identifier" and token.value in typetable
#            term = terminals["type_name"]
        else
            term = terminals.get(keywords.get(token.name, token.name))
        assert parser.expecting(term)
            print(toks...)
            print("EXPECTED", parser.expect...)
            print(c.format_source(token), "GOT", term, token)
            "C parsing failed"
        parser.step(term, token, token, token)
        if parser.accepted
            toks = []
            result = parser.traverse(post)
            print(result(scope))
            print(scope.variables.keys()...)
            #print(result(all_types))
            parser = c.language.new_parser()
            parser.default_ambiguity_resolution = ambiguity

    assert parser.chart.length == 1, "parser not finished?"

# Yes, this is hairy the spider.
# You'll be fine as long as you don't touch it.
# The hairy takes care of ambiguity in C grammar.

# Note that hairy doesn't corrupt scope, because declaration
# is no longer ambiguous when the declaration() gets called.

# Note that hairy neither messes up with list/first/append
# because there is no ambiguity in C list rules.
# well.. with the grammar we use..
ambiguity = (sppf, traverse):
# was used for diagnosis
#    print("ambiguity detected on", sppf.cell, c.format_source(sppf.start))
#    print(sppf.start, sppf.stop)
#    for branch in sppf
#        print("BRANCH")
#        for sub in branch
#            print("  ", sub.cell)
#            print("    ", sub.start, sub.stop)
    fn = (scope, args...):
        res = []
        for branch in sppf
            try
                res.append(traverse(branch)(scope, args...))
            except Conflict as conflict
                null
        # Should perhaps coalesce the conflicts if we get to raise.
        if res.length == 0 # A merit in storing traceback on your exception.
            raise conflict # This retains the traceback.
        assert res.length == 1, "unable to resolve ambiguity" # should never happen in C.
        return res[0]
    return chartparser.Resolve(fn)

class Conflict extends Exception
    +init = (self, token, which):
        self.traceback = null
        self.token = token
        self.which = which

    +repr = (self):
        return c.format_source(self.token) ++ "Conflict on " ++ repr(self.token) ++
            ", it was expected to be " ++ self.which

class Scope
    +init = (self):
        self.variables = {}
        self.tags = [] # structures, enums, unions within this scope.
        self.decls = [] # all declarations.
        self.defs = [] # all definitions.

    is_type = (self, name):
        try
            info = self.variables[name]
            return info.type == "type"
        except KeyError as _
            return false

    declare = (self, declarator):
        self.variables[declarator.name] = decl = :exnihilo()
            if declarator.specifier.storage == "typedef"
                type = "type"
            else
                type = "variable"
            declarator = declarator
        self.decls.append(decl)

class Function
    +init = (self, declarator, body):
        self.declarator = declarator
        self.body = body

class Declarator
    +init = (self, token):
        self.token = token
        if token
            self.name = token.value
        else
            self.name = null
        self.specifier = null
        self.stack = null
        self.last = null

    +repr = (self):
        return "Declarator{" ++ repr(self.specifier) ++ ", " ++ self.name ++ "}"


class Specifier
    +init = (self):
        self.storage = null
        self.typespec = []
        self.qualifiers = set()
        self.specifier = self

    +repr = (self):
        out = []
        if self.storage
            out.append(self.storage)
        for spec in self.typespec
            out.append(repr(spec))
        out.extend(self.qualifiers)
        return "Specifier{" ++ " ".join(out) ++ "}"

class DataSpecifier
    +init = (self, token, name, fields):
        self.token = token
        self.name = name
        self.fields = fields

class EnumSpecifier
    +init = (self, name):
        self.name = name
        self.enums = []


class Binary
    +init = (self, lhs, op, rhs):
        self.lhs = lhs
        self.op = op
        self.rhs = rhs

class Sizeof
    +init = (self, sz):
        self.sz = sz

class Constant
    +init = (self, token):
        self.token = token

class Reference
    +init = (self, name, value):
        self.name = name
        self.value = value

    +repr = (self):
        return "Ref{" ++ self.name ++ "}"
