import fs
import vulkan

#    Desc0 = DescriptorSetLayout(device, bindings = [
#        {
#            binding = 0
#            descriptorType = "UNIFORM_BUFFER"
#            descriptorCount = 1
#            stageFlags = "VERTEX_BIT"
#        }
#    ])
#    descset = Desc0()

class DescriptorSetLayout
    +init = (self, device, declaration):
        self.device = device
        self.declaration = declaration
        print("creating descriptor set layout")
#        self.device = device
#        self.bindings = bindings
#        self.layout = vulkan.DescriptorSetLayout(device,
#            {bindings = bindings})

    +call = (self):
        print("instantiating a set")
        return DescriptorSet(self)
#        pool = vulkan.DescriptorPool(self.device,
#            desc_pool_config(self.bindings, 1))
#        descset = self.device.allocateDescriptorSets({
#            descriptorPool = pool
#            setLayouts = [self.layout]
#        })[0]
#        descset.pool = pool
#        return descset
#    destroy = (self):
#        self.layout.destroy()

#desc_pool_config = (config, maxSets):
#    poolSizes = {}
#    for desc in config
#        type = desc["descriptorType"]
#        count = desc["descriptorCount"]
#        if type not in poolSizes
#            poolSizes[type] = { type = type, descriptorCount = count }
#        else
#            poolSizes[type]["descriptorCount"] += count
#    return {maxSets = maxSets, poolSizes = list(poolSizes.values())}

class DescriptorSet
    +init = (self, layout):
        self = Id(self)
        self.setattr("layout", layout)
        self.setattr("pending", [])

    +getattr = (self, name):
        if name in self.getattr("layout").declaration
            return DescriptorAttribute(self, name)
        return self.getattr(name)

    +setattr = (self, name, value):
        if name in self.getattr("layout").declaration
            self.getattr("pending").append([name, value])
        else
            self.setattr(name, value)

# https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorType
# The descriptorType reveals which Info -field should be used.
# dstArrayElement & *Info array count matters on arrays.


class DescriptorAttribute
    +init = (self, descset, name):
        self.descset = descset
        self.name = name

updateDescriptorSets = (changes):
    if not isinstance(changes, list)
        changes = [changes]

    for descset in changes
        proxy = Id(descset)
        for item in proxy.getattr("pending")
            print(descset, item, "changed")
        proxy.setattr("pending", [])

    #    device.updateDescriptorSets([{
    #        dstSet = descset
    #        dstBinding = 0
    #        dstArrayElement = 0
    #        descriptorType = "UNIFORM_BUFFER"
    #        bufferInfo = [{
    #            buffer = ubo.buffer
    #            offset = 0
    #            range  = ubo.buffer.size
    #        }]
    #    }], [])

# TODO: Implement descriptor copy as well.
#       Very simple and similar model appears to be.
#          srcSet
#          srcBinding
#          srcArrayElement
#          dstSet
#          dstBinding
#          dstArrayElement
#          descriptorCount




class ShaderLoader
    +init = (self, device, local):
        self.device = device
        self.local = local
        self.cache = {}

    fetch = (self, description):
        stages = []
        for item in description.items()
            stage = item[0]
            info = item[1].rsplit(":")
            path = self.local ++ info[0]
            try
                module = self.cache[path]
            except KeyError as e
                data = fs.read_file(path, "b")
                module = vulkan.ShaderModule(self.device, {
                    codeSize = data.length
                    pCode = data
                })
                self.cache[path] = module
            stages.append({
                stage = stage.upper() ++ "_BIT"
                module = module
                name = info[1]
            })
        return stages

    destroy = (self):
        for module in self.cache.values()
            module.destroy()
        self.cache = {}
