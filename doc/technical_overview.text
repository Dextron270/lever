<doc title="Technical overview"/>

This is a quick rundown through the main features of the
language. It is written for programmers that want to know
what Lever has to offer. 

<h1>Operators</h1>

Lever is a dynamically typed object based programming
language where objects provide enough invariance to provide
a type-inferenced variation of the language for "free".

Objects in Lever are accessed through operators. Operators
are callable objects that select their implementation
from their arguments. There are operators for...

<ul>
    <li>(==), hash: Equality between objects can be
    determined.</li>
    
    <li>call: Object can be called.</li>

    <li>(in)/getitem/setitem/iter: Object contains
    other objects, it can be indexed or iterated.</li>

    <li>product: Object can be broken into a
    tuple.</li>

    <li>pattern: Object can be used as a pattern to
    match other objects.</li>

    <li>cmp: Objects can be compared.</li>

    <li>(++) Objects can be concatenated together</li>

    <li>Arithmetic operators such as (+)/(-) allow
    arithmetic on objects.</li>

    <li>Attribute access is treated as a large group of
    operators.</li>

    <li>The user of the language may provide more operators
    if they are needed.</li>
</ul>

Whenever an operator is called, it may select its
implementation from a single or multiple arguments. If the
implementation is selected from a single argument then the
operator resolves to a method of that argument.

If the implementation of an operator is chosen from multiple
arguments, then a type of those arguments is extracted and
it is used to find an unique coercion into a single type.
Then that single type is used to select a method and the
arguments used for selection are converted into the same
type.

<h1>Coercions</h1>

Coercion is defined through a function 'unique_coercion'
that retrieves a set of types and returns an unique coercion
if there exists one.

The 'unique_coercion' function finds every type from the
set, that every other type in that set can be implicitly
coerced to. If it finds more than one coercion, then it
behaves as if there was no such type.

Generally coercions have to be defined on type basis, but
types can be marked base or composite types. There exist an
implicit, lifting coercion between base and composite types.

The coercion system allows great tools to be made for
symbolic computation and numerical analysis, and it allows
those tools to interoperate.

<h1>Invariant modules</h1>

Modules and all the contents of modules are enforced to be
invariant. This ensures modules are reusable within
different tasks in a process without leaking state between
those tasks.

Variance is determined on object-basis. That is, in two
objects of same type, one may be invariant and another may
be not. But type may also refer on only variant objects,
eg. mutable lists and dictionaries.

<h1>Type inference</h1>

A type inference can be run on any module that is loaded.
The results of the type inference can be memoized, reused
and passed around along the module.

Static type checking for turing-complete languages must be
incomplete. That means there are correct programs that are
rejected by the type checking. My viewpoint is that those
rejected programs include, not only interesting programs,
but also some useful ones. Therefore the type inference is
not required for all programs.

The main purpose for type inferencing is further refinement
of the software. This opens up new options that make
software development less error prone and more effective.

For example, it is possible to write a PNG decoder in Lever
that is as fast or even faster than the decoder written in
C.  This can be achieved by optimizing the paeth filtering
step that the decoder has to do after decompression.

<h1>Datatypes</h1>

Lever provides several primitive datatypes with behaviors
you cannot conveniently implement inside the language,
though almost everything is behind an operator that user
can define for his own types.

This is a result of having to split some types such as lists
due to the multiple ways they are used in a statically typed
environment. Besides there was a lot of challenge in getting
the type system arranged to fit both dynamic and static typing
into same object space.

For user defined datatypes I decided to provide parametric,
tagged unions. They allow the user to create abstract datatypes
that properly hide how they're implemented. They also encourage
writing of more immutable structures, and we can check that their
case clauses cover all possibilities there are.

<h1>Scoping rules</h1>

The scope is lexical and it is divided into three parts:

<ul>
    <li>Shadow: Variables defined earlier in local scope, but
        not necessarily live.</li>
    <li>Live: Variables that have been written and
        are verified to be live.</li>
    <li>All: All variables defined in current scope.</li>
</ul>

The liveness for variables is calculated by flow analysis. The
details of how this is specifically done during parsing is
still partially open.

A closure will obtain cells that are writable and readable
in its scope, from the point where it is defined. 'All' variables
defined in the scope form the part that are readable. 'Live' forms
the set of variables that are writable.

If a variable inside closure is not writable in closure's upscope,
the closure will define a local variable.

If a variable is defined within a loop, it does not escape
that loop, and it is referenced upscope, that variable gets a
small subscope that ensures that every closure produced within
a loop gets an unique reference.

On the topmost level of a script, the local scope is only used
within loops, and assignments end up stored in the module.

The details of the scope are abstracted before the code
reaches interpreter.

<h1>Parsing</h1>

Parsing is driven from a file with a generic-purpose parser,
just like in the previous version. Changing the file changes
the language.

<h1>Coeffects</h1>

Coeffects manifest in structures that resemble dynamic scope
variables. Each coeffect defines a set of variables in a
module that have to be bound in the context where the function
using them gets called. 

The difference to the traditional dynamic scope is that the
the access to the dynamic variables end up described in the
type of the function if it is type inferenced.
