file =>
    empty_list:
    statements

block => pass(statements): indent statements dedent

statements =>
    first:           block_statement
    append(lhs rhs): lhs=statements newline rhs=block_statement

block_statement =>
    pass: statement
    return(statement):
        kw_return:"return" statement
    if(statement block otherwise):
        kw_if:"if" statement block otherwise

otherwise =>
    done:
    elif(statement block otherwise):
        newline kw_elif:"elif" statement block otherwise
    else(block):
        newline kw_else:"else" block

statement =>
    pass: expr

expr =>
    expr20
    binary: expr plus:"+" expr20
    binary: expr minus:"-" expr20

expr20 =>
    prefix
    binary: expr star:"*" prefix
    binary: expr slash:"/" prefix
    binary: expr percent:"%" prefix

prefix =>
    postfix
    prefix: plus:"+" postfix
    prefix: minus:"-" postfix

postfix =>
    term
    call(postfix arguments):
        postfix lp:"(" arguments rp:")"

arguments =>
    empty_list:
    arguments1
    pass(arguments1): arguments1 comma:","

arguments1 =>
    first: expr
    append(lst expr): lst=arguments1 comma:"," expr

term =>
    lookup:          symbol
    int:             int
    float:           float
    string:          string
    pass(expr):      lp:"(" expr rp:")"
    list(arguments): lb:"[" arguments rb:"]"


#statements =>
#    first:      flow_statement
#    append(lhs rhs): lhs=statements newline rhs=flow_statement
#
#flow_statement =>
#    pass: statement
#    return_stmt(statement):
#        return:"return" statement
#    if_stmt(statement block otherwise):
#        if:"if" statement block cond_chain
#
#    # while(statement block):
#    #     while:"while" statement block
#    # for_: for_bind block
#
#cond_chain =>
#    :
#    else_chain(block):
#        else:"else" block
#
#
#for_bind => for_bind(symbol iter_statement):
#    for:"for" symbol in:"in" iter_statement
#
#iter_statement => iter_statement: statement
#
#statement =>
#    pass: expr
#    call: expr arguments_1
#    assign(lhs statement):
#        lhs=symbol eq:"=" statement
#
#expr =>
#    expr20
#    binary: expr binary_spacing(plus:"+") expr20
#    binary: expr binary_spacing(minus:"-") expr20
#
#expr20 =>
#    prefix
#    binary: expr binary_spacing(star:"*") prefix
#    binary: expr binary_spacing(slash:"/") prefix
#    binary: expr binary_spacing(percent:"%") prefix
#
#prefix =>
#    postfix
#    prefix: prefix_spacing(plus:"+") postfix
#    prefix: prefix_spacing(minus:"-") postfix
#
#postfix =>
#    term
#    call(postfix arguments):
#        postfix tight(lp:"(") arguments rp:")"
#    getattr(postfix symbol):
#        postfix dot:"." symbol
#    getitem(postfix expr):
#        postfix tight(lb:"[") expr rb:"]"
#
#arguments =>
#    empty_list:
#    append:     arguments expr
#
#arguments_1 =>
#    append:     arguments expr
#
#term =>
#    function(bindings):
#        lp:"(" bindings rp:")" colon:":" block
#
#bindings =>
#    empty_list:
#    append:     bindings binding
#
#binding => binding: symbol
#
