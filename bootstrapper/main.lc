import fs, grammar, json

language = grammar.read_file(dir ++ "../lever-0.10.0.grammar")

# The task of this software is to scan the prelude directory
# and produce a .json dump for every file in there.
main = ():
    prelude = path(dir ++ "../prelude")
    for entry in fs.scandir(prelude)
        if entry.type == "file" and entry.path.endswith(".lc")
            src = prelude ++ entry.path
            dst = prelude ++ (entry.path ++ ".json")
            compile_file(src, dst)

# The directory is scanned through and every file is
# compiled with the following function.
compile_file = (src, dst):
    sources = [src.relpath(dst.dirname).to_string()]
    parse = language.read_file(src)
    program = parse.traverse((name, args, loc):
        ast = actions[name](args...)

        loc = (start=loc.start, stop=loc.stop, src=0)
        set_loc = (this):
            if this.loc == null
                this.loc = loc
                this.traverse(set_loc)
        set_loc(ast)
        return ast)
    # The first traverse of the parse produces objects
    # with the table of actions that is described later.
    # After that everything is packed into a function and
    # the scope is solved as a second step.
    function = Script(program, sources)
    solve_scope(function)

    # Conversion into json is a temporary measure. It is too
    # vicious act to produce source location numbering
    # for this.
    json.write_file(dst, js(function), {indent=4})

# The bootstrapping process will ensure that the runtime is
# able to load and evaluate the scripts, but it will do
# nothing else.

# There is a second stage that does the proper job at
# bootstrapping. The second stage obtains the modules, type
# inferences them and then stores it all into an image.

actions = {
    "import": (name):
        return Assign(Symbol(name),
            Call(Symbol(u"import"), [Literal("string", name)]))
    "import_bind": (name, bindings):
        return Bind(
            Call(Symbol(u"import"), [Literal("string", name)]),
            bindings)
    "bind_coeffect": (fields, slot):
        return BindCoeffect(fields, slot)
    "closure": (args, body):
        return Closure(args, body)
    "generator": (body):
        return Generator(body)
    "argument": (arg):
        return Argument(arg)
    "cond": (cond, tb, fb=[]):
        return Cond(cond, tb, fb)
    "repeat": (heads, body):
        return Repeat(heads, body)
    "for_loop": (slot, expr):
        return ForLoop(slot, expr)
    "while_loop": (cond):
        return WhileLoop(cond)
    "if_loop": (cond):
        return IfLoop(cond)
    "datatype": (head, rows, decls):
        return Datatype(head, rows, decls)
    "no_label": (value):
        return Label(null, value)
    "with_label": (label, value):
        return Label(label, value)
    "method_declaration": (op, value):
        return MethodDecl(op, value)
    "derived_declaration": (ops, value):
        return DerivedDecl(ops, value)
    "attribute_declaration": (name, value):
        return AttrDecl(name, value, "attr")
    "attribute_set_declaration": (name, value):
        return AttrDecl(name, value, "attr_set")
    "attribute_method_declaration": (name, value):
        return AttrDecl(name, value, "attr_method")
    "case": (value, cases, default=[]):
        return Case(value, cases, default)
    "inline_except": (statement, excepts):
        return Except([statement], excepts)
    "assert": (cond, value):
        return Assert(cond, value)
    "raise": (value):
        return Raise(value)
    "constant_case": (value, body):
        return ConstantCase(value, body)
    "pattern_case": (pattern, slots, body):
        if slots.length == 1
            return PatternCase(pattern, slots[0], body)
        else
            return PatternCase(pattern, Tuple(slots), body)
    "return": (expr=Symbol("null")):
        return Return(expr)
    "yield": (expr=Symbol("null")):
        return Yield(expr)
    "break": ():
        return Break()
    "continue": ():
        return Continue()
    "assign": (slot, value):
        return Assign(slot, value)
    "inplace_assign": (slot, op, value):
        return InplaceAssign(slot, op, value)
    "symbol": (a):
        return Symbol(a)
    "item": (base, index):
        return Item(base, index)
    "attr": (base, name):
        return Attr(base, name)
    "prefix_symbol": (a):
        return Symbol(a ++ "expr")
    "tuple": (slots):
        return Tuple(slots)
    "call": (callee, args):
        return Call(callee, args)
    "binary": (lhs, op, rhs):
        return Call(Symbol(op), [lhs, rhs])
    "prefix": (op, rhs):
        return Call(Symbol(op ++ "expr"), [rhs])
    "iter_once": (value, slot):
        return IterOnce(value, slot)

    "and": (lhs, rhs):
        return And(lhs, rhs)
    "or": (lhs, rhs):
        return Or(lhs, rhs)
    "not": (rhs):
        return Not(rhs)

    "in": (lhs, rhs):
        return Call(Symbol("in"), [lhs, rhs])
    "not_in": (lhs, rhs):
        return Not(Call(Symbol("in"), [lhs, rhs]))

    "cmp": (chain, rhs):
        exprs = []
        operators = []
        for lhs, op in chain
            exprs.append(lhs)
            operators.append(Symbol(op))
        exprs.append(rhs)
        return Cmp(exprs, operators)
    "make_tuple": (items):
        return MakeTuple(items)
    "list": (values):
        return List(values)
    "deref": (value):
        return Deref(value)
    "record": (fields):
        return Record(fields)
    "record_shorthand": (label):
        return Field(name, false, Symbol(name))
    "mutable_record_shorthand": (label):
        return Field(name, true, Symbol(name))
    "field": (name, value=null):
        return Field(name, false, value)
    "mutable_field": (name, value=null):
        return Field(name, true, value)
    "rational": (repr):
        return Literal("rational", repr)
    "integer": (repr):
        return Literal("integer", repr)
    "string": (repr):
        return Literal("string", repr)
}

# TODO: When I wrote it the first time, I didn't completely explain how
#       the scope works. We should not assume that it works.
class Scope
    +init = (self, module):
        self.module = module    # assign into a module.
        self.rd = {}            # readable part of the env {var: slot}
        self.wd = {}            # writeable part of the env {var: slot}
        self.sh = set()         # shadowed part of the env {var}
        self.parent = null  # these two solve the frame.   
        self.depend = set()
        self.localvars = []
        self.cellvars = []

    get_frame = (self):
        frame = []
        i = 0
        for dep in self.depend
            frame.append(self.parent.cellvars.index(dep))
            assert self.cellvars[i] == dep
            i += 1
        return frame

class Cell
    +init = (self, name):
        self.deref = false
        self.name = name
        self.defs = 1

    to_json = (self):
        return {
            type = "cell",
            deref = self.deref,
            name = self.name,
            defs = self.defs }


# The solve_scope is broken because after two subsequent loops we
# may end up with a corrupted shadow and break the scope. The whole scope
# handler has to resume to the drawing board, before we are finished..
solve_scope = (function, global_wd=set()):
    scope = function.scope
    shadow = set()
    locals = {}
    macro = {}
    cells = []

    flow = (this):
        if isinstance(this, [Closure, Generator])
            for var, cell in scope.wd.items()
                this.scope.wd[var] = cell
            for var, cell in locals.items()
                this.scope.wd[var] = cell
        elif isinstance(this, BindCoeffect)
            for field in this.fields
                if field.mutable
                    global_wd.add(field.name)
            this.traverse(flow)
        elif isinstance(this, Symbol)
            if this.wronly
                if this.deep and this.name in scope.wd
                    this.cell = cell = scope.wd[this.name]
                    this.cell.defs += 1
                    scope.depend.add(cell)
                elif this.deep and scope.module
                    this.global = true
                elif this.name in locals
                    shadow.discard(this.name)
                    this.cell = locals[this.name]
                    this.cell.defs += 1
                elif this.name in global_wd
                    this.global = true
                else
                    cell = Cell(this.name)
                    cells.append(cell)
                    shadow.discard(this.name)
                    locals[this.name] = cell
                    this.cell = cell
            else
                if this.name in macro
                    this.macro = macro[this.name]
                assert this.name not in shadow
                    ["variable", this.name, "in shadow"]
                if this.name in locals
                    this.cell = locals[this.name]
                elif this.name in scope.rd
                    scope.rd[this.name].deref = true
                    this.cell = scope.rd[this.name]
                    scope.depend.add(scope.rd[this.name])
                else
                    this.global = true
                    assert this.name not in scope.sh,
                        ["variable", this.name, "in topscope shadow"]
            assert this.cell != null or this.global
        elif isinstance(this, Cond)
            # At Cond, there is not really subscope, but the
            # shadow set still needs to be made.
            flow(this.cond)
            p_locals = locals
            locals := dict(locals)
            for stmt in this.t_body
                flow(stmt)
            t_locals = dict(locals)
            for var in locals
                if var not in p_locals
                    shadow.add(var)
            for stmt in this.f_body
                flow(stmt)
            for var, cell in locals.items()
                if var in t_locals
                    shadow.discard(var)
                else
                    shadow.add(var)
        elif isinstance(this, Repeat)
            tmp_module = scope.module
            scope.module = false
            p_locals = locals
            locals := dict(locals)
            this.traverse(flow)
            for var, cell in locals.items()
                if var not in p_locals
                    shadow.add(var)
                    this.sublocals[var] = cell
            locals := p_locals
            this.scope = scope
            scope.module = tmp_module
        elif isinstance(this, Datatype)
            # The macro mechanism was added for the datatypes.
            # It is supposed to replace the parameters with
            # variables and ensure they're visible only inside the 
            # datatype declaration.
            flow(this.slot)
            p_macro = macro
            macro := dict(p_macro)
            for i in range(this.vars.length)
                name = this.vars[i]
                macro[name] = { type = "var", index = 0 }
            for constructor, fields in this.rows
                flow(constructor)
                for field in fields
                    flow(field)
            macro := p_macro
            for decl in this.decls
                flow(decl)
        else
            this.traverse(flow)
    function.traverse(flow)

    # At this point 'locals' tell the local values in scope
    # And 'shadow' tell the shadowed values. Variable goes to
    # shadowed if not certain that it is set.

    subscope = (this):
        if isinstance(this, Repeat)
            p_locals = locals
            locals := dict(locals)
            locals.update(this.sublocals)
            this.traverse(subscope)
            locals := p_locals
        elif isinstance(this, [Closure, Generator])
            this.scope.sh.update(scope.sh)
            this.scope.sh.update(shadow) # shadow -group
                                         # contains all shadowed wars
            for var, cell in scope.rd.items()
                this.scope.rd[var] = cell
                this.scope.sh.discard(var)
            for var, cell in locals.items()
                this.scope.rd[var] = cell
                this.scope.sh.discard(var)
            # The depend-set is built from 'rd', so we have to check
            # which depends should be carried over.
            solve_scope(this, global_wd)
            for dep in this.scope.depend
                if dep in scope.rd
                    depend.add(d)
            this.scope.parent = scope
        elif isinstance(this, Symbol)
            this.scope = scope
        else
            this.traverse(subscope)
    function.traverse(subscope)

    for cell in scope.depend
        scope.cellvars.append(cell)
    for cell in cells
        if cell.deref
             scope.cellvars.append(cell)
        else
             scope.localvars.append(cell)

# Expressions are distinguished so that we can extend
# them with 'Return' in closures.
class Expr

class Script
    +init = (self, body, sources):
        self.body = body
        self.scope = Scope(true)
        self.sources = sources

    traverse = (self, f):
        for stmt in self.body
            f(stmt)

    to_json = (self):
        assert self.scope.depend.length == 0
        return {
            type = "script",
            cellvars = js(self.scope.cellvars),
            localvars = js(self.scope.localvars),
            body = js(self.body),
            sources = self.sources }

class Closure extends Expr
    +init = (self, args, body):
        self.args = args
        self.body = body
        self.scope = Scope(false)
        self.loc = null
        for arg in args
            arg.slot.slotconfig(false, true)
        if body.length == 1 and isinstance(body[0], Expr)
            self.body = [Return(body[0])]

    traverse = (self, f):
        for arg in self.args
            f(arg)
        for stmt in self.body
            f(stmt)

    to_json = (self):
        return {
            type = "closure",
            cellvars = js(self.scope.cellvars),
            localvars = js(self.scope.localvars),
            frame = self.scope.get_frame(),
            args = js(self.args),
            body = js(self.body),
            loc = js_loc(self.loc)
        }

class Generator extends Expr
    +init = (self, body):
        self.body = body
        self.scope = Scope(false)
        self.loc = null

    traverse = (self, f):
        for stmt in self.body
            f(stmt)

    to_json = (self):
        return {
            type = "generator",
            cellvars = js(self.scope.cellvars),
            localvars = js(self.scope.localvars),
            frame = self.scope.get_frame(),
            body = js(self.body) }

class Argument
    +init = (self, slot):
        self.slot = slot
        self.loc = null

    traverse = (self, f):
        f(self.slot)

    to_json = (self):
        return {
            slot = js(self.slot) }

class Bind
    +init = (self, module, bindings):
        self.module = module
        self.loc = null
        self.bindings = dict(bindings)

    traverse = (self, f):
        f(self.module)

    to_json = (self):
        return {
            type = "bind",
            module = js(self.module),
            bindings = self.bindings,
            loc = js_loc(self.loc) }

class BindCoeffect
    +init = (self, fields, slot):
        self.fields = fields
        self.slot = slot
        self.loc = null

    traverse = (self, f):
        for field in self.fields
            f(field)
        f(self.slot)

    to_json = (self):
        return {
            type = "bind_coeffect",
            fields = js(self.fields),
            slot = js(self.slot) }

class Assign
    +init = (self, slot, value):
        slot.slotconfig(true, true)
        self.slot = slot
        self.value = value
        self.loc = null

    traverse = (self, f):
        f(self.slot)
        f(self.value)

    to_json = (self):
        return {
            type = "assign",
            slot = js(self.slot),
            value = js(self.value) }

class InplaceAssign
    +init = (self, slot, op, value):
        slot.slotconfig(true, false)
        self.slot = slot
        self.op = op
        self.value = value
        self.loc = null

    traverse = (self, f):
        f(self.slot)
        f(self.op)
        f(self.value)

    to_json = (self):
        return {
            type = "inplace_assign",
            slot = js(self.slot),
            op = js(self.op),
            value = js(self.value) }


class Cmp extends Expr
    +init = (self, exprs, ops):
        self.exprs = exprs
        self.ops = ops
        self.loc = null

    traverse = (self, f):
        for expr in self.exprs
            f(expr)
        for op in self.ops
            f(op)

    to_json = (self):
        return {
            type = "cmp",
            exprs = js(self.exprs)
            ops = js(self.ops),
            loc = js_loc(self.loc) }

class Symbol extends Expr
    +init = (self, name):
        self.name = name
        self.global = false
        self.deep = false
        self.wronly = false
        self.scope = null
        self.cell = null
        self.loc = null
        self.macro = null

    slotconfig = (self, deep, wronly):
        self.deep = deep
        self.wronly = wronly

    traverse = (self, f):
        null

    to_json = (self):
        if self.macro
            return js(self.macro)
        if self.global
            mode = "global"
            return {
                type = "slot",
                kind = "global",
                name = self.name,
                loc = js_loc(self.loc) }
        elif self.cell.deref
            return {
                type = "slot",
                kind = "cell",
                index = self.scope.cellvars.index(self.cell) }
        else
            return {
                type = "slot",
                kind = "local",
                index = self.scope.localvars.index(self.cell) }

class Item extends Expr
    +init = (self, base, index):
        self.base = base
        self.index = index
        self.loc = null

    slotconfig = (self, deep, wronly):
        null

    traverse = (self, f):
        f(self.base)
        f(self.index)

    to_json = (self):
        return {
            type = "slot",
            kind = "item",
            base = js(self.base),
            index = js(self.index),
            loc = js_loc(self.loc) }

class Deref extends Expr
    +init = (self, value):
        self.value = value
        self.loc = null

    slotconfig = (self, deep, wronly):
        null

    traverse = (self, f):
        f(self.value)

    to_json = (self):
        return {
            type = "slot",
            kind = "deref",
            value = js(self.value),
            loc = js_loc(self.loc) }

class Record extends Expr
    +init = (self, fields):
        self.fields = fields
        self.loc = null

    traverse = (self, f):
        for field in self.fields
            f(field)

    to_json = (self):
        return {
            type = "record"
            fields = js(self.fields)
        }

class Field
    +init = (self, name, mutable, value=null):
        self.name = name
        self.mutable = mutable
        self.value = value
        self.loc = null

    traverse = (self, f):
        if self.value
            f(self.value)

    to_json = (self):
        if self.value
            return {name=self.name, mutable=self.mutable, value=js(self.value)}
        else
            return {name=self.name, mutable=self.mutable}

class Attr extends Expr
    +init = (self, base, name):
        self.base = base
        self.name = name
        self.loc = null

    slotconfig = (self, deep, wronly):
        null

    traverse = (self, f):
        f(self.base)

    to_json = (self):
        return {
            type = "slot",
            kind = "attr",
            base = js(self.base),
            name = self.name,
            loc = js_loc(self.loc) }

class Tuple extends Expr
    +init = (self, slots):
        self.slots = slots
        self.loc = null

    slotconfig = (self, deep, wronly):
        for slot in self.slots
            slot.slotconfig(deep, wronly)

    traverse = (self, f):
        for slot in self.slots
            f(slot)

    to_json = (self):
        return {
            type = "slot",
            kind = "tuple",
            slots = js(self.slots),
            loc = js_loc(self.loc) }

class MakeTuple extends Expr
    +init = (self, items):
        self.items = items
        self.loc = null

    traverse = (self, f):
        for item in self.items
            f(item)

    to_json = (self):
        return { type = "make_tuple", items = js(self.items) }

#TODO: Continue from here.

# How closures should work: frames and subframes
#   shadowing transparency:
#     if the variable is defined in the subframe, it should
#     be shadowed from that point on.
#
#   Assign to variables above the defpoint.
#   But fetch from the whole scope.
#
#   Variable slot appears on the frame where the variable
#   is defined on.
#
#   repeat -subframe
#     expect that the subframe might not be run.
#
#   conditional -subframes
#     allow the variable pass into parent frame only
#     if it appears on all of the flowpaths.
#
#   closure always fetches from the whole scope above it.
#
#   The separate 'assignment' is removed. Not longer needed
#   because the topmost scope is immutable.

# We are not checking .sh on write.
# This is a fringe case arising from the need
# to do shadowing for the variables.
#
# I am certain that somebody, possibly a highly paid
# consultant, will argue for checking a shadow on write
# when inside a closure.
#
# The shadowing mechanism in itself is used to ensure that
# the user is not harmed by the unusual scoping rules that
# allow consistent and useful behavior for nested functions
# inside repetition clauses.
#
# When we get outside of certain precaution, the usefulness of
# the measures decrease while the inconvenience increases.
#
# If there was a check in here then we would get
# consultants argue that it should not be there.

# TODO: On toplevel, we got to "pierce" holes for the
#       global scope, so that assignments hit mutable
#       elements.

# Every value imported using "from" will be retrieved through
# "bind", and set writable. This allows the doctools to
# identify imported variables and define their origins,
# while they stay out of the scope.

# Must note that it won't work with "from" * -syntax.

class Cond
    +init = (self, cond, t_body, f_body):
        self.cond = cond
        self.t_body = t_body
        self.f_body = f_body
        self.loc = null

    traverse = (self, f):
        f(self.cond)
        for stmt in self.t_body
            f(stmt)
        for stmt in self.f_body
            f(stmt)
        
    to_json = (self):
        return {
            type = "cond",
            cond = js(self.cond),
            tbody = js(self.t_body),
            fbody = js(self.f_body),
            loc = js_loc(self.loc) }

class Repeat
    +init = (self, heads, body):
        self.heads = heads
        self.body = body
        self.sublocals = {}
        self.scope = null
        self.loc = null

    traverse = (self, f):
        for head in self.heads
            f(head)
        for stmt in self.body
            f(stmt)
        
    to_json = (self):
        fresh = []
        # TODO: associate to the repeater and add 'fresh' -field.
        for var, cell in self.sublocals.items()
            if cell.deref
                fresh.append(self.scope.cellvars.index(cell))
        return {
            type = "repeat",
            fresh = fresh,
            heads = js(self.heads),
            body = js(self.body) }

class ForLoop
    +init = (self, slot, value):
        self.slot = slot
        self.value = value
        self.loc = null
        slot.slotconfig(false, true)

    traverse = (self, f):
        f(self.slot)
        f(self.value)

    to_json = (self):
        return {
            type = "for",
            slot = js(self.slot),
            value = js(self.value) }

class WhileLoop
    +init = (self, cond):
        self.cond = cond
        self.loc = null

    traverse = (self, f):
        f(self.cond)

    to_json = (self):
        return {
            type = "while",
            cond = js(self.cond) }

class IfLoop
    +init = (self, cond):
        self.cond = cond
        self.loc = null

    traverse = (self, f):
        f(self.cond)

    to_json = (self):
        return {
            type = "if",
            cond = js(self.cond) }

class Datatype
    +init = (self, head, rows, decls):
        self.slot = head[0]
        self.vars = head[1]
        self.rows = rows
        self.decls = decls
        self.loc = null
        self.slot.slotconfig(false, true)
        for constructor, fields in self.rows
            constructor.slotconfig(false, true)

    traverse = (self, f):
        f(self.slot)
        for constructor, fields in self.rows
            f(constructor)
            for field in fields
                f(field)
        for decl in self.decls
            f(decl)

    to_json = (self):
        return {
            type = "datatype",
            slot = js(self.slot),
            vars = js(self.vars),
            rows = js(self.rows),
            decls = js(self.decls),
            loc = js_loc(self.loc) }

class Label
    +init = (self, label, value):
        self.label = label
        self.value = value
        self.loc = null

    traverse = (self, f):
        f(self.value)

    to_json = (self):
        if self.label
            return {
                type = "label",
                name = self.label,
                value = js(self.value) }
        else
            return {
                type = "no_label",
                value = js(self.value) }

class MethodDecl
    +init = (self, op, value):
        self.op = op
        self.value = value
        self.loc = null

    traverse = (self, f):
        f(self.op)
        f(self.value)

    to_json = (self):
        return {
            type = "method",
            op = js(self.op),
            value = js(self.value) }

class DerivedDecl
    +init = (self, ops, value):
        self.ops = ops
        self.value = value
        self.loc = null

    traverse = (self, f):
        for op in self.ops
            f(op)
        f(self.value)

    to_json = (self):
        return {
            type = "derived",
            ops = js(self.ops),
            value = js(self.value) }

class AttrDecl
    +init = (self, name, value, which):
        self.name = name
        self.value = value
        self.which = which
        self.loc = null

    traverse = (self, f):
        f(self.value)

    to_json = (self):
        return {
            type = self.which,
            name = self.name,
            value = js(self.value) }

class Case
    +init = (self, value, cases, default):
        self.value = value
        self.cases = cases
        self.default = default
        self.loc = null

    traverse = (self, f):
        f(self.value)
        for case in self.cases
            f(case)
        for stmt in self.default
            f(stmt)

    to_json = (self):
        return {
            type = "case",
            value = js(self.value),
            cases = js(self.cases),
            default = js(self.default),
            loc = js_loc(self.loc) }

class Except
    +init = (self, body, excepts):
        self.body = body
        self.excepts = excepts
        for exc, slot, exc_body in self.excepts
            if slot
                slot.slotconfig(false, true)
        self.loc = null

    traverse = (self, f):
        for stmt in self.body
            f(stmt)
        for exc, slot, exc_body in self.excepts
            f(exc)
            if slot
                f(exc)
            for stmt in exc_body
                f(stmt)

    to_json = (self):
        excepts = []
        for exc, slot, exc_body in self.excepts
            if slot
                excepts.append({exc = exc, slot = slot, body=exc_body})
            else
                excepts.append({exc = exc, body=exc_body})
        return {
            type = "except",
            body = js(self.body),
            excepts = js(excepts),
            loc = js_loc(self.loc) }

class Assert
    +init = (self, cond, value):
        self.cond = cond
        self.value = value
        self.loc = null

    traverse = (self, f):
        f(self.cond)
        f(self.value)

    to_json = (self):
        return {
            type = "assert",
            cond = js(self.cond),
            value = js(self.value),
            loc = js_loc(self.loc) }

class Raise
    +init = (self, value):
        self.value = value

    traverse = (self, f):
        f(self.value)

    to_json = (self):
        return {
            type = "raise",
            value = js(self.value),
            loc = js_loc(self.loc) }

class ConstantCase
    +init = (self, value, body):
        self.value = value
        self.body = body
        self.loc = null

    traverse = (self, f):
        f(self.value)
        for stmt in self.body
            f(stmt)

    to_json = (self):
        return {
            type = "constant",
            value = js(self.value),
            body = js(self.body),
            loc = js_loc(self.loc) }

class PatternCase
    +init = (self, pattern, slot, body):
        self.pattern = pattern
        self.slot = slot
        self.body = body
        slot.slotconfig(false, true)
        self.loc = null

    traverse = (self, f):
        f(self.pattern)
        f(self.slot)
        for stmt in self.body
            f(stmt)

    to_json = (self):
        return {
            type = "pattern",
            pattern = js(self.pattern),
            slot = js(self.slot),
            body = js(self.body),
            loc = js_loc(self.loc) }

class Return
    +init = (self, value):
        self.value = value
        self.loc = null

    traverse = (self, f):
        f(self.value)

    to_json = (self):
        return { type = "return", value = js(self.value) }

class Yield
    +init = (self, value):
        self.value = value
        self.loc = null

    traverse = (self, f):
        f(self.value)

    to_json = (self):
        return { type = "yield", value = js(self.value) }

class Break
    +init = (self):
        self.loc = null

    traverse = (self, f):
        null

    to_json = (self):
        return { type = "break" }

class Continue
    +init = (self):
        self.loc = null

    traverse = (self, f):
        null

    to_json = (self):
        return { type = "continue" }

class Call extends Expr
    +init = (self, callee, args):
        self.callee = callee
        self.args = args
        self.loc = null

    traverse = (self, f):
        f(self.callee)
        for arg in self.args
            f(arg)

    to_json = (self):
        return {
            type = "call",
            callee = js(self.callee),
            args = js(self.args),
            loc = js_loc(self.loc) }

class IterOnce extends Expr
    +init = (self, value, slot):
        self.value = value
        self.slot = slot
        self.loc = null
        slot.slotconfig(false, true)

    traverse = (self, f):
        f(self.value)
        f(self.slot)

    to_json = (self):
        return {
            type = "iter_once",
            value = js(self.value),
            slot = js(self.slot),
            loc = js_loc(self.loc) }

class And extends Expr
    +init = (self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs
        self.loc = null

    traverse = (self, f):
        f(self.lhs)
        f(self.rhs)

    to_json = (self):
        return {
            type = "and",
            lhs = js(self.lhs),
            rhs = js(self.rhs),
            loc = js_loc(self.loc) }

class Or extends Expr
    +init = (self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs
        self.loc = null

    traverse = (self, f):
        f(self.lhs)
        f(self.rhs)

    to_json = (self):
        return {
            type = "or",
            lhs = js(self.lhs),
            rhs = js(self.rhs),
            loc = js_loc(self.loc) }

class Not extends Expr
    +init = (self, value):
        self.value = value
        self.loc = null

    traverse = (self, f):
        f(self.value)

    to_json = (self):
        return {
            type = "not",
            value = js(self.value),
            loc = js_loc(self.loc) }

class List extends Expr
    +init = (self, values):
        self.values = values
        self.loc = null

    traverse = (self, f):
        for value in self.values
            f(value)

    to_json = (self):
        return {
            type = "list",
            values = js(self.values) }

class Literal extends Expr
    +init = (self, kind, repr):
        self.kind = kind
        self.repr = repr
        self.loc = null

    traverse = (self, f):
        null

    to_json = (self):
        return {
            type = "literal",
            kind = self.kind,
            value = self.repr }

# The 'loc' field appears on constructs that may fail for
# one or another reason. The source in json format is
# verbose enough so this is a big help.
js_loc = (loc):
    if loc == null
        loc = (start=(lno=0,col=0), stop=(lno=0,col=0), src=0)
    return [loc.start.col, loc.start.lno, loc.stop.col, loc.stop.lno, loc.src]

js = (obj):
    if isinstance(obj, list)
        r = []
        for i in obj
            r.append(js(i))
        return r
    elif isinstance(obj, dict)
        r = {}
        for k, v in obj.items()
            r[k] = js(v)
        return r
    elif isinstance(obj, str)
        return obj
    elif isinstance(obj, int)
        return obj
    else
        return obj.to_json()
