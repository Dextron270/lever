from console import get_system_console
import compiler
import base

main = :
    console = get_system_console()
    this = :module("console", base)
        dir = getcwd()
        name = "console"
        %"import" = Import(dir,
            ModuleScope(dir, %"import".scope.parent))
        console = console
    print("LEVER 0.x.x")

    buffer = []
    while true
        prompt = ">> "
        if buffer.length > 0
            prompt = "   "
        string = console.input(prompt)
        buffer.append(string)

        try
            source = "\n".join(buffer)
#             add_history(source)
            print("\033[32;2m"++source++"\033[0m")
 
            code = compiler.read_string(source, "console")
            print("\033[33;1m"++repr(load(code)(this))++"\033[0m")
        except compiler.SyntaxError as syn
            if syn.at_eof
                continue
            print("\033[35;1m"++repr(syn)++"\033[0m")
        except Exception as exc
            print_traceback(exc)
        buffer = []

# main2 = :
#     attempt_completion := (results, prefix):
#         scope = null
#         start = 0
#         try
#             word = ""
#             i = 0
#             for ch in prefix
#                 if ch == "."
#                     if scope
#                         scope = getattr(scope, word)
#                     else
#                         scope = getattr(console, word)
#                     word = ""
#                     start = i+1
#                 else
#                     word ++= ch
#                 i += 1
#             prefix = word
#         except AttributeError as e
#             return 0
#         if scope
#             completion_scan(results, prefix, scope)
#         else
#             completion_scan(results, prefix, console)
#             completion_scan(results, prefix, base)
#         results.sort()
#         return start
# 
#     completion_scan = (results, prefix, obj):
#         for name in listattr(obj)
#             if name == prefix
#                 term_completion_apropos := apropos(name, getattr(obj, name))
#                 continue
#             if name.length > 0 and not name[0].is_alpha()
#                 continue
#             if name.startswith(prefix)
#                 results.append(name)
# 
# apropos = (name, obj):
#     try
#         if isinstance(obj, interface)
#             result = "class " ++ name ++ format_spec(
#                 getattr(obj, "+init").spec)
#         else
#             result = name ++ format_spec(obj.spec)
#     except AttributeError as attr
# 
#         if isinstance(obj, multimethod)
#             result = name ++ " " ++ repr(obj) ++ format_multimethod(obj)
#         else
#             result = name ++ " = " ++ repr(obj)
#     return result
# 
# format_multimethod = (mm):
#     res = StringBuilder()
#     for argtypes in mm.keys()
#         res.append("\n    " ++ repr(argtypes) ++ format_spec(mm[argtypes].spec, []))
#     return res.build()
# 
# format_spec = (spec, argtypes=null):
#     res = StringBuilder()
#     res.append("(")
# 
#     comma = ""
#     varnames = varnames_then_some_more(spec.varnames)
#     if not argtypes
#         argtypes = []
#         try
#             if spec.argtypes
#                 argtypes = list(spec.argtypes)
#         except AttributeError as attr
#             null
#     for i in range(spec.argc)
#         res.append(comma)
# 
#         vname = varnames.next()
#         res.append(vname)
#         if argtypes.length > 0
#             tname = repr(argtypes.pop(0))
#             if tname != vname
#                 res.append(":")
#                 res.append(tname)
#         comma = ", "
# 
#     for i in range(spec.optional)
#         res.append(comma)
# 
#         res.append("[")
#         vname = varnames.next()
#         res.append(vname)
#         if argtypes.length > 0
#             tname = repr(argtypes.pop(0))
#             if tname != vname
#                 res.append(":")
#                 res.append(tname)
#         res.append("]")
#         comma = ", "
#     
#     if spec.is_variadic
#         res.append(comma)
#         res.append(varnames.next())
#         res.append("...")
# 
#     res.append(")")
#     return res.build()
# 
# varnames_then_some_more = (varnames):
#     if varnames
#         for name in varnames
#             yield name
#     n = ord("a")
#     while true
#         yield chr(n)
#         n += 1
# 
# max_history_length = 1000
# term_history = []
# add_history = (text):
#     term_history.append(text)
#     if term_history.length > max_history_length
#         term_history.pop(0)
# 
# term_completion_apropos = null
# term_completion_options = null
# term_seg0 = []
# term_seg1 = []
# term_readline = Event()
# term_prompt = ""
# term_history_index = -1
# input = (next_prompt):
#     term_prompt := next_prompt
#     return term_readline.wait()
# 
# term_editor_loop = :
#     while true
#         for s in ansi_read_sequence()
#             term_completion_apropos := null
#             term_completion_options := null
#             if s == "\r" or s == "\n"
#                 line = "".join(term_seg0 ++ term_seg1)
#                 term_seg0 := []
#                 term_seg1 := []
#                 term_history_index := -1
#                 term_readline.dispatch(line)
#                 continue
#             if s == "\t"
#                 results = []
#                 start = attempt_completion(results, "".join(term_seg0))
#                 if results.length == 1
#                     term_seg0 := term_seg0[0 .: start]
#                     term_seg0.extend(results[0])
#                 elif results.length > 1
#                     term_completion_options := results
#                 continue
#             if s == "\x1b[A"
#                 if term_history.length == 0
#                     continue
#                 if term_history_index == -1
#                     term_history_index := term_history.length - 1
#                 else
#                     term_history_index -= 1
#                 term_history_index := clamp(term_history_index, 0, term_history.length-1)
#                 term_seg0 := list(term_history[term_history_index])
#                 term_seg1 := []
#                 continue
#             if s == "\x1b[B"
#                 if term_history.length == 0
#                     continue
#                 elif term_history_index == -1
#                     continue
#                 elif term_history_index == term_history.length - 1
#                     term_seg0 := []
#                     term_seg1 := []
#                     continue
#                 else
#                     term_history_index += 1
#                 term_history_index := clamp(term_history_index, 0, term_history.length-1)
#                 term_seg0 := list(term_history[term_history_index])
#                 term_seg1 := []
#                 continue


# 
#         if term_completion_options
#             column = 1
#             for option in term_completion_options
#                 column = max(column, option.length + 2)
# 
#             rows = term_completion_options[0 .: 15]
#             j = 15
#             for x in range(column, width-column, column)
#                 i = 0
#                 for option in term_completion_options[j .: j+15]
#                     rows[i] ++= (x - rows[i].length)*" "
#                     rows[i] ++= option
#                     i += 1
#                     j += 1
# 
#             seg1 ++= "\n" ++ "\n".join(rows)
#             if term_completion_options.length >= 10
#                 seg1 ++= "..."
# 
#         if term_completion_apropos
#             seg1 ++= "\n" ++ term_completion_apropos
