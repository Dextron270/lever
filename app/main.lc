from console import get_system_console, LineEditor
import console
import compiler
import base

main = :
    console = get_system_console()
    this = :module("console", base)
        dir = getcwd()
        name = "console"
        %"import" = Import(dir,
            ModuleScope(dir, %"import".scope.parent))
        console = console
        toys = ():
            console.refresh_interval = 0.016
            toy = ProgressToy(console, "arbitrary progress")
            console.attach(toy)
            toy = ColorToy(console)
            console.attach(toy)
            toy = FPSCounterToy(console)
            console.attach(toy)
    print("LEVER 0.x.x")

    buffer = []
    while true
        prompt = ">> "
        if buffer.length > 0
            prompt = "   "
        string = console.input(prompt)
        buffer.append(string)

        try
            source = "\n".join(buffer)
#             add_history(source)
            print("\033[32;2m"++source++"\033[0m")
 
            code = compiler.read_string(source, "console")
            print("\033[33;1m"++repr(load(code)(this))++"\033[0m")
        except compiler.SyntaxError as syn
            if syn.at_eof
                continue
            print("\033[35;1m"++repr(syn)++"\033[0m")
        except Exception as exc
            print_traceback(exc)
        buffer = []

class FPSCounterToy # "lol"
    +init = (self, console):
        self.console = console
        self.now = time()

    refresh = (self, sketch):
        now = time()
        sketch.append("FPS ")
        sketch.append(int(1.0/(now-self.now)).to_string())
        self.now = now
        self.console.refresh()

class ColorToy
    +init = (self, console):
        self.console = console
    
    refresh = (self, sketch):
        for x in range(sketch.width)
            sketch.color(
                vec3(random(), random(), random()),
                vec3(random(), random(), random()))
            sketch.append("#")
        sketch.normal()
        self.console.refresh()

class ProgressToy
    +init = (self, console, label=null):
        self.console = console
        self.label = label
        self.progress = 0.0
        self.now = time()
        self.running = true

    refresh = (self, sketch):
        now = time()
        self.progress += (now - self.now) / 10
        self.now = now
        if self.progress >= 1.0 and self.running
            schedule(self.console.detach, self)
            if self.label
                self.console.log("info", [self.label, "done"])
            self.running = false
        w = min(43, sketch.width-2)
        k = int(w * self.progress)
        sketch.color(vec3(1,1,1))
        if self.label
            sketch.append(self.label)
            sketch.append(" ")
        sketch.append("|")
        for x in range(k)
            sketch.color(vec3(1,1,1))
            sketch.append("#")
        for x in range(k, w)
            sketch.color(vec3(0,0,0))
            sketch.append("-")
        sketch.color(vec3(1,1,1))
        sketch.append("| ")
        sketch.append(int(self.progress * 100).to_string() ++ "%")
        sketch.normal()
        self.console.refresh()

# Starting point.
# class InputVisual
#     +init = (self, console, prompt):
#         self.console = console
#         self.prompt = prompt
#         self.response = Event()
#         self.editor = LineEditor()
# 
#     process = (self, ch):
#         if self.editor.process(ch)
#             return true
#         if ch == "\r" or ch == "\n"
#             self.response.dispatch(self.editor.get_line())
#             self.console.detach(self)
#             return true
#         return false
# 
#     refresh = (self, sketch):
#         sketch.append(self.prompt)
#         self.pos = self.editor.refresh(sketch)






# main2 = :
#     attempt_completion := (results, prefix):
#         scope = null
#         start = 0
#         try
#             word = ""
#             i = 0
#             for ch in prefix
#                 if ch == "."
#                     if scope
#                         scope = getattr(scope, word)
#                     else
#                         scope = getattr(console, word)
#                     word = ""
#                     start = i+1
#                 else
#                     word ++= ch
#                 i += 1
#             prefix = word
#         except AttributeError as e
#             return 0
#         if scope
#             completion_scan(results, prefix, scope)
#         else
#             completion_scan(results, prefix, console)
#             completion_scan(results, prefix, base)
#         results.sort()
#         return start
# 
#     completion_scan = (results, prefix, obj):
#         for name in listattr(obj)
#             if name == prefix
#                 term_completion_apropos := apropos(name, getattr(obj, name))
#                 continue
#             if name.length > 0 and not name[0].is_alpha()
#                 continue
#             if name.startswith(prefix)
#                 results.append(name)
# 
# apropos = (name, obj):
#     try
#         if isinstance(obj, interface)
#             result = "class " ++ name ++ format_spec(
#                 getattr(obj, "+init").spec)
#         else
#             result = name ++ format_spec(obj.spec)
#     except AttributeError as attr
# 
#         if isinstance(obj, multimethod)
#             result = name ++ " " ++ repr(obj) ++ format_multimethod(obj)
#         else
#             result = name ++ " = " ++ repr(obj)
#     return result
# 
# format_multimethod = (mm):
#     res = StringBuilder()
#     for argtypes in mm.keys()
#         res.append("\n    " ++ repr(argtypes) ++ format_spec(mm[argtypes].spec, []))
#     return res.build()
# 
# format_spec = (spec, argtypes=null):
#     res = StringBuilder()
#     res.append("(")
# 
#     comma = ""
#     varnames = varnames_then_some_more(spec.varnames)
#     if not argtypes
#         argtypes = []
#         try
#             if spec.argtypes
#                 argtypes = list(spec.argtypes)
#         except AttributeError as attr
#             null
#     for i in range(spec.argc)
#         res.append(comma)
# 
#         vname = varnames.next()
#         res.append(vname)
#         if argtypes.length > 0
#             tname = repr(argtypes.pop(0))
#             if tname != vname
#                 res.append(":")
#                 res.append(tname)
#         comma = ", "
# 
#     for i in range(spec.optional)
#         res.append(comma)
# 
#         res.append("[")
#         vname = varnames.next()
#         res.append(vname)
#         if argtypes.length > 0
#             tname = repr(argtypes.pop(0))
#             if tname != vname
#                 res.append(":")
#                 res.append(tname)
#         res.append("]")
#         comma = ", "
#     
#     if spec.is_variadic
#         res.append(comma)
#         res.append(varnames.next())
#         res.append("...")
# 
#     res.append(")")
#     return res.build()
# 
# varnames_then_some_more = (varnames):
#     if varnames
#         for name in varnames
#             yield name
#     n = ord("a")
#     while true
#         yield chr(n)
#         n += 1
# 
# max_history_length = 1000
# term_history = []
# add_history = (text):
#     term_history.append(text)
#     if term_history.length > max_history_length
#         term_history.pop(0)
# 
# term_completion_apropos = null
# term_completion_options = null
# term_seg0 = []
# term_seg1 = []
# term_readline = Event()
# term_prompt = ""
# term_history_index = -1
# input = (next_prompt):
#     term_prompt := next_prompt
#     return term_readline.wait()
# 
# term_editor_loop = :
#     while true
#         for s in ansi_read_sequence()
#             term_completion_apropos := null
#             term_completion_options := null
#             if s == "\r" or s == "\n"
#                 line = "".join(term_seg0 ++ term_seg1)
#                 term_seg0 := []
#                 term_seg1 := []
#                 term_history_index := -1
#                 term_readline.dispatch(line)
#                 continue
#             if s == "\t"
#                 results = []
#                 start = attempt_completion(results, "".join(term_seg0))
#                 if results.length == 1
#                     term_seg0 := term_seg0[0 .: start]
#                     term_seg0.extend(results[0])
#                 elif results.length > 1
#                     term_completion_options := results
#                 continue
#             if s == "\x1b[A"
#                 if term_history.length == 0
#                     continue
#                 if term_history_index == -1
#                     term_history_index := term_history.length - 1
#                 else
#                     term_history_index -= 1
#                 term_history_index := clamp(term_history_index, 0, term_history.length-1)
#                 term_seg0 := list(term_history[term_history_index])
#                 term_seg1 := []
#                 continue
#             if s == "\x1b[B"
#                 if term_history.length == 0
#                     continue
#                 elif term_history_index == -1
#                     continue
#                 elif term_history_index == term_history.length - 1
#                     term_seg0 := []
#                     term_seg1 := []
#                     continue
#                 else
#                     term_history_index += 1
#                 term_history_index := clamp(term_history_index, 0, term_history.length-1)
#                 term_seg0 := list(term_history[term_history_index])
#                 term_seg1 := []
#                 continue


# 
#         if term_completion_options
#             column = 1
#             for option in term_completion_options
#                 column = max(column, option.length + 2)
# 
#             rows = term_completion_options[0 .: 15]
#             j = 15
#             for x in range(column, width-column, column)
#                 i = 0
#                 for option in term_completion_options[j .: j+15]
#                     rows[i] ++= (x - rows[i].length)*" "
#                     rows[i] ++= option
#                     i += 1
#                     j += 1
# 
#             seg1 ++= "\n" ++ "\n".join(rows)
#             if term_completion_options.length >= 10
#                 seg1 ++= "..."
# 
#         if term_completion_apropos
#             seg1 ++= "\n" ++ term_completion_apropos
