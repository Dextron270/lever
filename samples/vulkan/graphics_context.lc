# Initializes a graphics context
import api, ffi, fs
import util

sdl2_init = (sdl, win, width, height):
    lib = api.open_nobind("libvulkan", {})
    g = exnihilo()
    g.vk = vk = ffi.library("libvulkan.so", lib)

    ci = {
        sType = "INSTANCE_CREATE_INFO"
        enabledExtensionCount = 2
        ppEnabledExtensionNames = ["VK_KHR_surface", "VK_KHR_xcb_surface"]
    }
    instance = ffi.automem(vk.Instance, 1, true)
    check(vk.createInstance(ci, null, instance))
    g.instance = instance = instance.to

    # Temporary measure, not going to work everywhere
    count = ffi.automem(ffi.u32)
    vk.enumeratePhysicalDevices(instance, count, null)
    devices = ffi.automem(vk.PhysicalDevice, count.to)
    vk.enumeratePhysicalDevices(instance, count, devices)
    if count.to <= 0
        print("no vulkan device found")
        exit(1)
    g.gpu = gpu = devices[0]

    # Because it's not going to work everywhere, lets print the graphics card name.
    gpuinfo = ffi.automem(vk.PhysicalDeviceProperties)
    vk.getPhysicalDeviceProperties(gpu, gpuinfo)
    print("graphics device:", gpuinfo.deviceName.str)

    # Another temporary measure. The queue should be picked from the queue families here.
    # This only works reliably on NVIDIA
    ci = {
        sType = "DEVICE_CREATE_INFO"
        queueCreateInfoCount = 1
        pQueueCreateInfos = [
            {
                sType = "DEVICE_QUEUE_CREATE_INFO"
                queueFamilyIndex = 0
                queueCount = 1
                pQueuePriorities = [1.0]
            }
        ]
        enabledExtensionCount = 1
        ppEnabledExtensionNames = ["VK_KHR_swapchain"]
    }
    dev = ffi.automem(vk.Device, 1, true)
    check(vk.createDevice(gpu, ci, null, dev))
    g.dev = dev = dev.to

    if not vk.deviceWaitIdle(dev).SUCCESS
        exit(1)

    ## Window creation
    ## Third temporary measure, this only works on linux.
    info = ffi.automem(sdl.SysWMinfo)
    info.version = {major=2, minor=0, patch=2}

    if sdl.GetWindowWMInfo(win, info) == 0
        exit(1)

    if info.subsystem == sdl.SYSWM_X11
        VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000
        ci = {
            sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR
            connection = info.info.x11.display
            window = ffi.cast(info.info.x11.window, ffi.voidp)
        }
        surface = ffi.automem(vk.SurfaceKHR)
        print(vk.createXcbSurfaceKHR)
        check(vk.createXcbSurfaceKHR(instance, ci, null, surface))
        g.surface = surface = surface.to 
    else
        print("WSI for your system need to be implemented for this code to work.")
        exit(1)

    # Fourth temporary measure, no idea where this works.
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000
    ci = vkmem(vk.SwapchainCreateInfoKHR, VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, 1)
    ci = {
        sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
        surface = surface
        minImageCount = 2
        imageFormat = "B8G8R8A8_UNORM" # hack
        imageColorSpace = 0 # ?
        imageExtent = {width = width, height = height} # GetPhysicalDeviceSurfaceCapabilitiesKHR, GetPhysicalDeviceSurfacePresentModesKHR
        imageUsage = "COLOR_ATTACHMENT_BIT" # | vk.IMAGE_USAGE_TRANSFER_DST_BIT
        preTransform = "IDENTITY_BIT_KHR" # ?
        compositeAlpha = "OPAQUE_BIT_KHR"
        imageArrayLayers = 1
        imageSharingMode = "EXCLUSIVE"
        #queueFamilyIndexCount = 0
        #pQueueFamilyIndices = null
        presentMode = "FIFO_KHR"
        #oldSwapchain = null
        clipped = true
    }
    swapchain = ffi.automem(vk.SwapchainKHR)
    check(vk.createSwapchainKHR(dev, ci, null, swapchain))
    g.swapchain = swapchain = swapchain.to

    count = ffi.automem(ffi.u32)
    vk.getSwapchainImagesKHR(dev, swapchain, count, null)
    g.images = images = ffi.automem(vk.Image, count.to)
    vk.getSwapchainImagesKHR(dev, swapchain, count, images)
    g.images_count = count.to

    ## Queue
    queue = ffi.automem(vk.Queue)
    vk.getDeviceQueue(dev, 0, 0, queue)
    g.queue = queue.to

    ## Command pool
    ci = {
        sType = "COMMAND_POOL_CREATE_INFO"
        flags = "RESET_COMMAND_BUFFER_BIT"
        queueFamilyIndex = 0
    }
    commandpool = ffi.automem(vk.CommandPool)
    check(vk.createCommandPool(dev, ci, null, commandpool))
    g.commandpool = commandpool.to

    methods(g)

    return g

methods = (gx):
    vk = gx.vk
    gx.new_semaphore = ():
        ci = {sType = "SEMAPHORE_CREATE_INFO"}
        semaphore = ffi.automem(vk.Semaphore)
        check(vk.createSemaphore(gx.dev, ci, null, semaphore))
        return semaphore.to

    gx.submit1 = (waitsemaphores, commandbuffers, signalsemaphores, fence):
        si = [{
            sType = "SUBMIT_INFO"
            waitSemaphoreCount = waitsemaphores.length
            pWaitSemaphores = waitsemaphores
            commandBufferCount = commandbuffers.length
            pCommandBuffers = commandbuffers
            signalSemaphoreCount = signalsemaphores.length
            pSignalSemaphores = signalsemaphores
        }]
        check(vk.queueSubmit(gx.queue, 1, si, fence))

    gx.cmd_begin = (cbuf, flags):
        bi = {
            sType = "COMMAND_BUFFER_BEGIN_INFO"
            flags = flags
        }
        check(vk.beginCommandBuffer(cbuf, bi))

    gx.cmd_end = (cbuf):
        check(vk.endCommandBuffer(cbuf))

    gx.acquire_next_image = (signal):
        x = ffi.automem(ffi.u32)
        check(vk.acquireNextImageKHR(gx.dev, gx.swapchain, 0xFFFFFFFFFFFFFFFF, signal, null, x))
        return x.to

    gx.present = (waitsemaphores, imageIdx):
        VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001
        pi = {
            sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
            waitSemaphoreCount = waitsemaphores.length
            pWaitSemaphores = waitsemaphores
            swapchainCount = 1
            pSwapchains = [gx.swapchain]
            pImageIndices = [imageIdx]
            pResults = null
        }
        check(vk.queuePresentKHR(gx.queue, pi))

    ## The following are needed when you render triangles.
    gx.load_shader = (path):
        return gx.create_shader(fs.read_file(path, "b"))

    gx.create_shader = (blob):
        ci = {
            sType = "SHADER_MODULE_CREATE_INFO"
            codeSize = blob.length
            pCode = blob
        }
        module = ffi.automem(vk.ShaderModule)
        check(vk.createShaderModule(gx.dev, ci, null, module))
        return module.to

    gx.create_descriptorpool = (flags, maxsets, poolsizes):
        pPoolSizes = []
        for pool in poolsizes
            pPoolSizes.append({type = pool[0], descriptorCount = pool[1]})
        ci = {
            sType = "DESCRIPTOR_POOL_CREATE_INFO"
            maxSets = maxsets
            poolSizeCount = pPoolSizes.length
            pPoolSizes = pPoolSizes
        }
        descriptorpool = ffi.automem(vk.DescriptorPool)
        check(vk.createDescriptorPool(gx.dev, ci, null, descriptorpool))
        return descriptorpool.to

    gx.new_descriptorsets = (descriptorpool, layouts):
        descset = ffi.automem(vk.DescriptorSet, layouts.length)
        ci = {
            sType = "DESCRIPTOR_SET_ALLOCATE_INFO"
            descriptorPool = descriptorpool
            descriptorSetCount = layouts.length
            pSetLayouts = layouts
        }
        check(vk.allocateDescriptorSets(gx.dev, ci, descset))
        return descset

    gx.alloc_memory = (size, typeindex):
        ci = {
            sType = "MEMORY_ALLOCATE_INFO"
            allocationSize = size
            memoryTypeIndex = typeindex
        }
        mem = ffi.automem(vk.DeviceMemory)
        check(vk.allocateMemory(gx.dev, ci, null, mem))
        return mem.to

    gx.create_buffer = (flags, size, usage):#, sharingMode, queuefamilies):
        #qfi = bufferlist(ffi.u32, queuefamilies)
        ci = {
            sType = "BUFFER_CREATE_INFO"
            flags = flags
            size = size
            usage = usage
        }
        buffer = ffi.automem(vk.Buffer)
        check(vk.createBuffer(gx.dev, ci, null, buffer))
        return buffer.to

    gx.create_imageview = (type, image, format):
        ci = {
            sType = "IMAGE_VIEW_CREATE_INFO"
            image = image
            viewType = type
            format = format
            components = { 
                r = "R"
                g = "G"
                b = "B"
                a = "A"
            }
            subresourceRange = {
                aspectMask = "COLOR_BIT"
                baseMipLevel = 0
                levelCount = 1
                baseArrayLayer = 0
                layerCount = 1
            }
        }
        imageview = ffi.automem(vk.ImageView)
        check(vk.createImageView(gx.dev, ci, null, imageview))
        return imageview.to

    gx.ImageMemoryBarrier = vkcifn(
        vk.ImageMemoryBarrier,
        "IMAGE_MEMORY_BARRIER")

    gx.DescriptorSetLayoutCreateInfo = vkcifn(
        vk.DescriptorSetLayoutCreateInfo,
        "DESCRIPTOR_SET_LAYOUT_CREATE_INFO")

    gx.PipelineCacheCreateInfo = vkcifn(
        vk.PipelineCacheCreateInfo,
        "PIPELINE_CACHE_CREATE_INFO")

    gx.PipelineLayoutCreateInfo = vkcifn(
        vk.PipelineLayoutCreateInfo,
        "PIPELINE_LAYOUT_CREATE_INFO")

    gx.RenderPassCreateInfo = vkcifn(
        vk.RenderPassCreateInfo,
        "RENDER_PASS_CREATE_INFO")

    gx.RenderPassBeginInfo = vkcifn(
        vk.RenderPassBeginInfo,
        "RENDER_PASS_BEGIN_INFO")

    gx.FramebufferCreateInfo = vkcifn(
        vk.FramebufferCreateInfo,
        "FRAMEBUFFER_CREATE_INFO")

    gx.GraphicsPipelineCreateInfo = vkcifn(
        vk.GraphicsPipelineCreateInfo,
        "GRAPHICS_PIPELINE_CREATE_INFO")

    gx.PipelineShaderStageCreateInfo = vkcifn(
        vk.PipelineShaderStageCreateInfo,
        "PIPELINE_SHADER_STAGE_CREATE_INFO")

    gx.PipelineVertexInputStateCreateInfo = vkcifn(
        vk.PipelineVertexInputStateCreateInfo,
        "PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO")

    gx.PipelineInputAssemblyStateCreateInfo = vkcifn(
        vk.PipelineInputAssemblyStateCreateInfo,
        "PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO")

    gx.PipelineTessellationStateCreateInfo = vkcifn(
        vk.PipelineTessellationStateCreateInfo,
        "PIPELINE_TESSELLATION_STATE_CREATE_INFO")

    gx.PipelineViewportStateCreateInfo = vkcifn(
        vk.PipelineViewportStateCreateInfo,
        "PIPELINE_VIEWPORT_STATE_CREATE_INFO")

    gx.PipelineRasterizationStateCreateInfo = vkcifn(
        vk.PipelineRasterizationStateCreateInfo,
        "PIPELINE_RASTERIZATION_STATE_CREATE_INFO")

    gx.PipelineMultisampleStateCreateInfo = vkcifn(
        vk.PipelineMultisampleStateCreateInfo,
        "PIPELINE_MULTISAMPLE_STATE_CREATE_INFO")

    gx.PipelineDepthStencilStateCreateInfo = vkcifn(
        vk.PipelineDepthStencilStateCreateInfo,
        "PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO")

    gx.PipelineColorBlendStateCreateInfo = vkcifn(
        vk.PipelineColorBlendStateCreateInfo,
        "PIPELINE_COLOR_BLEND_STATE_CREATE_INFO")

    gx.PipelineDynamicStateCreateInfo = vkcifn(
        vk.PipelineDynamicStateCreateInfo,
        "PIPELINE_DYNAMIC_STATE_CREATE_INFO")

    gx.check = (result):
        check(result)
        
vknew = (fn, struct, ci):
    obj = ffi.automem(struct)
    check(fn(ci, null, obj))
    return obj.to

vknew2 = (fn, struct, a, ci):
    obj = ffi.automem(struct)
    check(fn(a, ci, null, obj))
    return obj.to

vkmem = (struct, sType, count):
    ci = ffi.automem(struct, count)
    i = 0
    while i < count
        ci[i].sType = sType
        ci[i].pNext = null
        i += 1
    return ci

bufferlist = (struct, sequence):
    if sequence.length > 0
        buf = ffi.automem(struct, sequence.length)
        i = 0
        while i < sequence.length
            buf[i] = sequence[i]
            i += 1
        return buf
    return null

vkcifn = (struct, sType):
    return (count):
        return vkmem(struct, sType, count)

check = (result):
    if not result.SUCCESS
        # I could throw exception if I had remembered to setup initializers
        # for exception classes.. ohwell.
        print("error: result=", result)
        exit(1)

