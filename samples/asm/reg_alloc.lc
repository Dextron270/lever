import asm, fs, ffi, mman, platform
from asm import Address, Register, Relative, Immediate
from asm import i8, i16, i32, i64

jmp = {i32: 886, i8: 887}
jge = {i32: 875, i8: 876} # (SF=0F)
jle = {i32: 879, i8: 880} # (ZF=1 or SFâ‰ OF).

main = ():
    assert platform.arch == "x86_64"
        "It just might not work on x86"
    assert platform.name.startswith("linux")
        "Also this still depends on the SystemV calling conventions for a short while."

    benchmark(collision_ref_impl)

    # System V AMD64 ABI
    free_regs = {
        asm.GPR:[0,1,2,6,7,8,9,10,11],
        asm.MM:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] }
    # We may also want to reserve the base pointer (5)
    # So it is not in the list below
    save_regs = {
        asm.GPR:[3,12,13,14,15],
        asm.MM:[] }
    # Under the RSP we have so called 128-bytes of 'red zone' that can be
    # used for variables that can spill across function calls.


    arg_0 = Register(i64, 7) # RDI
    arg_1 = Register(i64, 6) # RSI
    arg_2 = Register(i64, 2) # RDX
    arg_3 = Register(i64, 1) # RCX
    arg_4 = Register(i64, 8)
    arg_5 = Register(i64, 9)

    r_points = arg_0
    r_count  = arg_1
    r_x = arg_2
    r_y = arg_3
    r_r = arg_4

    off_x = 0
    off_y = off_x + ffi.sizeof(ffi.long)
    off_r = off_y + ffi.sizeof(ffi.long)
    point_sz = ffi.sizeof(Point)



    entry = Block()
    loop  = Block()
    no_collision = Block()
    collision    = Block()

    v_i = Variable(i64)
    v_off = Variable(i64)
    v_dx = Variable(i64)
    v_dy = Variable(i64)
    v_rr = Variable(i64)
    v_dx2 = Variable(i64)
    v_dy2 = Variable(i64)
    v_ll2 = Variable(i64)
    v_rr2 = Variable(i64)

    # entry(points, count, x, y, r):
    #    i = 0
    entry.code = [
        Entry([r_points, r_count, r_x, r_y, r_r]),
        Operation(5973, [v_i, v_i]); # It is important to point out we are doing a clear here.
            operand_usages = ["USAGE_WRITE", null],
        Jump(jmp, loop)
    ]

    # loop(i, points, count, x, y, r):
    loop.code = [
        # if i >= count goto no_collision
        # CMP m64 r64
        Operation(475, [v_i, r_count]),
        Jump(jge, no_collision),
        # IMUL r64 m64 imm8
        Operation(811, [v_off, v_i, point_sz]),
        # dx = points[i].x - x
        # dy = points[i].y - y
        # rr = points[i].r + r
        # MOV r64 m64
        Operation(1125, [v_dx, Address(i64, off_x, r_points, v_off)]),
        Operation(1125, [v_dy, Address(i64, off_y, r_points, v_off)]),
        Operation(1125, [v_rr, Address(i64, off_r, r_points, v_off)]),
        # SUB r64 m64
        Operation(2327, [v_dx, r_x]),
        Operation(2327, [v_dy, r_y]),
        # ADD r64 m64
        Operation(73, [v_rr, r_r]),
        # dx2 = dx*dx
        # MOV r64, m64
        Operation(1125, [v_dx2, v_dx], true),
        # IMUL r64 r64
        Operation(819, [v_dx2, v_dx2]),
        # dy2 = dy*dy
        # MOV r64, m64
        Operation(1125, [v_dy2, v_dy], true),
        # IMUL r64 r64
        Operation(819, [v_dy2, v_dy2]),
        # rr2 = rr*rr
        # MOV r64, m64
        Operation(1125, [v_rr2, v_rr], true),
        # IMUL r64 r64
        Operation(819, [v_rr2, v_rr2]),
        # ll2 = dx2 + dy2
        # ADD r64 m64
        Operation(1125, [v_ll2, v_dx2], true),
        Operation(73, [v_ll2, v_dy2]),
        # if ll2 <= rr2 goto collision
        # CMP m64 r64
        Operation(475, [v_ll2, v_rr2]),
        Jump(jle, collision),
        # i += 1
        # ADD m64, imm8 (sign extend)
        Operation(55, [v_i, Immediate(i8, 1)]),
        Jump(jmp, loop) # jump loop(i, points, count, x, y, r)
    ]

    # no_collision(): return false
    no_collision.code = [
        # XOR m64 r64
        Operation(5973, [Register(i64, 0), Register(i64, 0)]),
        Operation(1901, []) # RET NEAR
    ]

    # collision():    return true
    collision.code = [
        # XOR m64 r64
        Operation(5973, [Register(i64, 0), Register(i64, 0)]),
        # MOV m8, imm8
        Operation(1128, [Register(i8, 0), Immediate(i8, 1)]),
        Operation(1901, []) # RET NEAR
    ]

    program = [
        entry,
        loop,
        no_collision,
        collision
    ]
    # Now.. Some loops and variables to allocate.
    # The variables should be divided by their type into bins.



    # Operands are picked up with .get_use_defs
    # and placed into asm.GPR or asm.MM using 'isinstance'
    changed = true
    while changed
        output = []
        changed = false
        for block in program
            changed = block.encode(output) or changed
    # Should produce 0xB0, 123, 0xC3

    # So that one can ndisasm this.
    # fd = fs.open(dir ++ "dump", fs.WRONLY | fs.CREAT | fs.TRUNC)
    # fd.pwrite(Uint8Array(output), 0)
    # fd.close()

    buf = mman.Asmbuf(4096)
    buf.memcpy(Uint8Array(output))
    buf.finalize()

    print("preparing the function pointer")
    c_type = ffi.cfunc(ffi.int, [
        ffi.pointer(Point), ffi.size_t, ffi.long, ffi.long, ffi.long
    ])

    c_func = ffi.cast(buf, c_type)
    print("new c function", c_func)
    print("call result:", c_func(null, 0, 0, 0, 0))
    buf.free() 

# The collision benchmark and a reference implementation
Point = ffi.struct([
    ["x", ffi.long],
    ["y", ffi.long],
    ["r", ffi.long],
])

benchmark = (check_collision):
    length = 1024 * 1024
    points = ffi.automem(Point, length)
    count = 0
    skip = 0
    was = time()
    while time() - was < 1.0
        x = int(random() * 10000)
        y = int(random() * 10000)
        r = int(random() * 10 + 1)
        if check_collision(points, count, x, y, r)
            skip += 1
        else
            assert count < length
            points[count].x = x
            points[count].y = y
            points[count].r = r
            count += 1
    print("count", count, "skip", skip)

collision_ref_impl = (points, count, x, y, r):
    for i in range(count)
        dx = points[i].x - x
        dy = points[i].y - y
        rr = points[i].r + r
        if dx*dx + dy*dy <= rr*rr
            return true
    return false


class Variable
    +init = (self, type):
        self.type = type
        self.index = -1

    resolve = (self):
        assert self.index >= 0, "Unresolved variable"
        return Register(self.type, self.index)

class Block
    +init = (self, code=[]):
        self.offset = 0
        self.code = code

    encode = (self, output):
        changed = self.offset != output.length
        self.offset = output.length
        for ins in self.code
            changed = ins.encode(output) or changed
        return changed

class BackendInstruction
    encode = (self, output):
        return

    get_use_defs = (self):
        return object({uses = [], defs = [], clobber = []})

class Entry extends BackendInstruction
    +init = (self, register_args):
        self.register_args = register_args
    
    get_use_defs = (self):
        return object({
            uses = []
            defs = list(self.register_args)
            clobber = []
        })

class Jump extends BackendInstruction
    +init = (self, uids, target):
        self.uids = uids
        self.target = target
        self.offset = 0

    encode = (self, output):
        offset = (self.target.offset - self.offset)
        if offset == 0 # The fall-through case.
            true
        elif -128 <= offset and offset < 128
            output.append( asm.encode_ins( self.uids[i8], Immediate(i8, offset) ) )
        else
            output.append( asm.encode_ins( self.uids[i32], Immediate(i32, offset) ) )
        changed = self.offset != output.length
        self.offset = output.length
        return changed

class Operation extends BackendInstruction
    +init = (self, uid, operands, is_move_related=false, clobber=[]):
        self.uid = uid
        self.operands = operands
        self.is_move_related = is_move_related
        self.operand_usages = get_operand_usages(uid)
        self.clobber = clobber

    encode = (self, output):
        output.extend( asm.encode_ins(self.uid, self.operands) )
        return false

    get_uses_defs = (self):
        uses = []
        defs = []
        clobber = []
        index = 0
        for operand in self.operands
            usage = self.operand_usages[index]
            if isinstance(operand, Address)
                if isinstance(operand.base, Variable)
                    uses.append(operand.base)
                if isinstance(operand.index, Variable)
                    uses.append(operand.index)
            elif usage == "USAGE_READ_WRITE"
                if isinstance(operand, Variable)
                    uses.append(operand)
                    defs.append(operand)
                elif isinstance(operand, Register)
                    clobber.append(operand)
            elif usage == "USAGE_READ"
                if isinstance(operand, Variable)
                    uses.append(operand)
            elif usage == "USAGE_WRITE"
                if isinstance(operand, Variable)
                    defs.append(operand)
                elif isinstance(operand, Register)
                    clobber.append(operand)
            else
                assert not usage, repr(usage)
            index += 1
        clobber.extend(self.clobber)
        return object({uses = uses, defs = defs, clobber = clobber})

get_operand_usages = (uid):
    syntax = asm.instructions[uid]["vendor_syntax"]
    operands = syntax["operands"]
    usage = []
    for operand in operands
        usage.append(operand["usage"])
    return usage


## IRC: https://www.cs.princeton.edu/research/techreps/TR-498-95
class IRC
    +init = (self, func, ebb_tiles):
        self.func = func
        self.ebb_tiles = ebb_tiles
        self.simplify_work = set()
        self.coalesce_work = set()
        self.freeze_work = set()
        self.spill_work = set()
        # adjacency data
        self.adj_set = set()
        self.adj_list = {}
        self.degree = {}
        #
        self.active_moves = set()
        self.coalesced_moves = set()
        self.move_list = {}
        self.precolored = set()
        self.constrained_moves = set()
        self.frozen_moves = set()
        #
        self.select_stack = []
        self.coalesced_nodes = []
        self.alias = {}
        #
        self.K = 16 # Lets try others later.
        self.spilled_nodes = set()
        self.colored_nodes = set()
        self.color = {}

    work = (self):
        # liveness_analysis() # Actually the IRC algorithm doesn't need to do full analysis.
        build_graph(self)
        mk_worklist(self)
        while (self.simplify_work.length +
               self.coalesce_work.length +
               self.freeze_work.length +
               self.spill_work.length) > 0
            if self.simplify_work.length > 0
                simplify(self)
            elif self.coalesce_work.length > 0
                coalesce(self)
            elif self.freeze_work.length > 0
                freeze(self)
            elif self.spill_work.length > 0
                select_spill(self)
        assign_colors(self)
        if self.spilled_nodes.length > 0
            rewrite_program(self.spilled_nodes)
            return self.work()
        return self.color

build_graph = (st): # procedure Build
    for ebb in st.func.ebbs
        live = set()
        for tile in reversed(st.ebb_tiles[ebb])
            if tile.spec.get("result", false)
                live.discard(tile.root)
                for l in live
                    add_edge(st, l, tile.root)
            for arg in tile.argv
                if isinstance(arg, native.Exit)
                    for val in arg.output.values()
                        live.add(val)
                elif isinstance(arg, [native.Op, native.Arg])
                    live.add(arg)
            for move in tile.spec.get("moves", [])
                dst = resolve_move(st, tile, move[0])
                src = resolve_move(st, tile, move[1])
                move = [dst,src]
                st.coalesce_work.add(move)
                try
                    st.move_list[dst].add(move)
                except KeyError as ke
                    st.move_list[dst] = set([move])
                try
                    st.move_list[src].add(move)
                except KeyError as ke
                    st.move_list[src] = set([move])
    args = list(st.func.entry.input.values())
    for i in range(1, args.length)
        for j in range(i)
            add_edge(st, args[i], args[j])

resolve_move = (st, tile, motion):
    if motion.startswith('i')
        return tile.argv[ parse_int(motion[1 .:]) ]
    elif motion == "result"
        return tile.root
    else # TODO: should not have to care about register size,
         #       only about the register class.
        arg = motion
        st.color[arg] = parse_int(motion[1 .:])
        st.precolored.add(arg) 
        return arg

add_edge = (st, u, v):
    lhs = [u, v]
    if lhs not in st.adj_set
        st.adj_set.add(lhs)
        st.adj_set.add([v, u])
        add_half_edge(st, u, v)
        add_half_edge(st, v, u)

add_half_edge = (st, u, v):
    if isinstance(u, [native.Arg, native.Op]) # not precolored if it's variable
        degree = st.degree.get(u, 0)
        if degree == 0
            st.degree[u] = 1
            st.adj_list[u] = [v]
        else
            st.degree[u] = degree + 1
            st.adj_list[u].append(v)

mk_worklist = (st):
    initial = st.adj_list.keys() # for now...
    for n in initial
        if st.degree[n] >= st.K
            st.spill_work.add(n)
        elif move_related(st, n)
            st.freeze_work.add(n)
        else
            st.simplify_work.add(n)
    # st.initial = set()

move_related = (st, n):
    return node_moves(st, n).length > 0

node_moves = (st, n):
    moves = st.move_list.get(n)
    if moves
        moves -= st.active_moves
        moves -= st.coalesce_work
        return moves
    else
        return set()

simplify = (st):
    n = st.simplify_work.pop()
    st.select_stack.append(n)
    for m in adjacent(st, n)
        decrement_degree(st, m)

decrement_degree = (st, m):
    d = st.degree[m]
    st.degree[m] = d - 1
    if d == st.K
        enable_moves(st, adjacent(st, m) ++ [m])
        st.spill_work.discard(m)
        if move_related(st, m)
            st.freeze_work.add(m)
        else
            st.simplify_work.add(m)

enable_moves = (st, nodes):
    for n in nodes
        for m in node_moves(st, n)
            if m in st.active_moves
                st.active_moves.pop(m)
                st.coalesce_work.add(m)

coalesce = (st):
    m = st.coalesce_work.pop()
    x = get_alias(st, m[0])
    y = get_alias(st, m[1])
    if y in st.precolored
        u = y
        v = x
    else
        u = x
        v = y
    if u == v
        st.coalesced_moves.add(m)
        add_worklist(st, u)
    elif v in st.precolored or [u,v] in st.adj_set
        st.constrained_moves.add(m)
        add_worklist(st, u)
        add_worklist(st, v)
    else
        coalesce = false
        if u in st.precolored
            for t in adjacent(v)
                if st.degree.get(t,0) < st.K
                    coalesce = true
                elif t in st.precolored
                    coalesce = true
                elif [t,u] in st.adj_set
                    coalesce = true
        else
            coalesce = conservative(st, adjacent(st, u) ++ adjacent(st, v))
        if coalesce
            st.coalesced_moves.add(m)
            combine(st, u,v)
        else
            st.active_moves.add(m)

add_worklist = (st, u):
    if (u not in st.precolored) and (not move_related(st, u)) and st.degree.get(u, 0) < st.K
        st.freeze_work.discard(u)
        st.simplify_work.add(u)

conservative = (st, nodes):
    k = 0
    for n in nodes
        if st.degree.get(n,0) >= st.K
            k += 1
    return k < st.K

get_alias = (st, n):
    while n in st.coalesced_nodes
        n = get_alias(st, st.alias[n])
    return n

combine = (st, u, v):
    st.freeze_work.discard(v)
    st.spill_work.discard(v)
    st.alias[v] = u
    for t in adjacent(st, v)
        decrement_degree(st, t)
        add_edge(st, t, u)

freeze = (st):
    u = st.freeze_work.pop()
    st.simplify_work.add(u)
    for m in node_moves(st, u)
        if m[0] == u
            v = m[1]
        else
            v = m[0]
        if m in st.active_moves
            st.active_moves.discard(m)
        else
            st.coalesce_work.discard(m)
        st.frozen_moves.add(m)
        if node_moves(st, v).length == 0 and st.degree.get(v,0) < st.K
            st.freeze_work.discard(v)
            st.simplify_work.add(v)

select_spill = (st):
    # selected using favorite heuristic
    # Note: avoid choosing nodes that are the tiny live ranges
    #       resulting from the fetches of previously spilled registers
    m = st.spill_work.pop()
    st.simplify_work.add(m)

assign_colors = (st):
    while st.select_stack.length > 0
        n = st.select_stack.pop()
        ok_colors = set()
        for i in range(st.K)
            ok_colors.add(st.K - i - 1)
        for w in adjacent(st, n) # nU (coloredNodes U precolored)
            if w in st.colored_nodes
                ok_colors.discard(st.color[w])
        if ok_colors.length == 0
            st.spilled_nodes.add(n)
        else
            st.colored_nodes.add(n)
            st.color[n] = ok_colors.pop() # TODO: select the "lowest color"
    for n in st.coalesced_nodes
        st.color[n] = st.color.get(get_alias(st, n))

adjacent = (st, n):
    adj = []
    for a in st.adj_list[n]
        if a in st.select_stack
            continue
        if a in st.coalesced_nodes
            continue
        adj.append(a)
    return adj

# Spill operation is done on the function objects..
# We go through the function with our spilled variables.
# Whenever a spilled variable is defined, we add:
# x = spill v 
# When there is an occurrence of 'v', we will insert
# z = unspill x
# and replace the 'v' with 'z'

# Not that on every 'Exit' we have to reorganize
# the variables to fit the 'jump-site'.
# With tight constraints, this can be done
# with series of 'xchg' and 'mov' commands.




# We check the program through in reverse:
#   If there is an output with spilled variable, we replace
#     the output with variable from the spill scope.
#   If the variable 


# procedure RewriteProgram()
#   allocate memory locations for each v in spilledNodes
#   create a new temporary v for each definiton and each use
#   in the program (instructions), insert a store after each
#   definition of a v[i], a fetch before each use of a v[i].
#   put all the v[i] into a set newTemps
#   spilledNodes = {}
#   initial = coloredNodes U coalescedNodes U newtemsp
#   coloredNodes = {}
#   coalescedNodes = {}
