import sdl
import vulkan, ffi, gc, api, fs

main = ():
    window = sdl.Window(name, {
        width = 512
        height = 512
    })

    gpu = GPU(window)

    device = gpu.device

    vertex_layout = object();
        input = {
            flags = 0
            vertexBindingDescriptions = [{
                binding = 0
                stride = 6 * ffi.sizeof(ffi.float)
                inputRate = "VERTEX"
            }]
            vertexAttributeDescriptions = [
                {
                    binding = 0
                    location = 0
                    format = "R32G32B32_SFLOAT"
                    offset = 0
                },
                {
                    binding = 0
                    location = 1
                    format = "R32G32B32_SFLOAT"
                    offset = 3 * ffi.sizeof(ffi.float)
                }
            ]
        }
        assembly = {topology = "TRIANGLE_LIST"}

    vbo = object();
        size = 8 * 1024
        buffer = gpu.mem.createBuffer(size, "VERTEX_BUFFER_BIT")
        data = buffer.mem.map(ffi.float, buffer.offset, buffer.size)
        stuff = [
            0.0, 0.0, 0.0, 1.0, 0.5, 0.5,
            0.0, 1.0, 0.0, 0.5, 1.0, 0.5,
            1.0, 0.0, 0.0, 0.5, 0.5, 1.0,
            0.0, 1.0, 0.0, 0.5, 0.5, 1.0,
            1.0, 1.0, 0.0, 0.5, 1.0, 1.0,
            1.0, 0.0, 0.0, 1.0, 1.0, 0.5,
        ]
        for i in range(stuff.length)
            data[i] = stuff[i]
        buffer.mem.unmap()

    ubo = object();
        size = 2 * 4 * 4 * ffi.sizeof(ffi.float)
        buffer = gpu.mem.createBuffer(size, "UNIFORM_BUFFER_BIT")
        data = buffer.mem.map(ffi.float, buffer.offset, buffer.size)
        stuff = [
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
           -0.2,-0.2, 0.0, 1.0,

            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0]
        for i in range(stuff.length)
            data[i] = stuff[i]
        buffer.mem.unmap()

    cbuf = gpu.queue.pool.allocate({level = "PRIMARY", commandBufferCount = 1})[0]

    descset_layout = vulkan.DescriptorSetLayout(device, {
        bindings = [{
            binding = 0
            descriptorType = "UNIFORM_BUFFER"
            descriptorCount = 1
            stageFlags = "VERTEX_BIT"
        }]
    })
    # DEP: pipeline_layout, descset

    pipeline_layout = vulkan.PipelineLayout(device, {
        flags = 0
        setLayouts = [descset_layout]
        pushConstantRanges = []
    })
    # DEP: cbuf, pipeline

    descriptor_pool = vulkan.DescriptorPool(device, {
        maxSets = 1
        poolSizes = [
            {type = "UNIFORM_BUFFER", descriptorCount = 1}
        ]
    })
    # DEP: descset

    descset = device.allocateDescriptorSets({
        descriptorPool = descriptor_pool
        setLayouts = [descset_layout]
    })[0]

    device.updateDescriptorSets([{
        dstSet = descset
        dstBinding = 0
        dstArrayElement = 0
        descriptorType = "UNIFORM_BUFFER"
        bufferInfo = [{
            buffer = ubo.buffer
            offset = 0
            range  = ubo.buffer.size
        }]
    }], [])
    # DEP: cbuf

    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002

    pass = gpu.default_pass();
        renderPass = vulkan.RenderPass(device, {
            attachments = [
                {
                    # These values will likely require adjustment.
                    format = gpu.swapchain.format
                    samples = "1_BIT"
                    loadOp = "CLEAR"
                    storeOp = "STORE"
                    stencilLoadOp = "DONT_CARE"
                    stencilStoreOp = "DONT_CARE"
                    initialLayout = 0 #UNDEFINED
                    finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR #"COLOR_ATTACHMENT_OPTIMAL"
                }
            ]
            subpasses = [
                {
                    pipelineBindPoint = "GRAPHICS"
                    inputAttachments = []
                    colorAttachments = [
                        {attachment = 0, layout = "COLOR_ATTACHMENT_OPTIMAL"}
                    ]
                }
            ]
        })
    # DEP: framebuffer, pipeline, cbuf

    swapchain = gpu.swapchain
    swapchain.views = []
    swapchain.fences = []
    swapchain.framebuffers = []
    for image in swapchain.images
        view = vulkan.ImageView(device, {
            image = image
            viewType = "2D"
            format = swapchain.format
            components = {r = "R", g = "G", b = "B", a = "A"}
            subresourceRange = swapchain.subresource_range
        })
        swapchain.views.append(view)
        # DEP: framebuffer

        fence = vulkan.Fence(device, {flags = "SIGNALED_BIT"})
        swapchain.fences.append(fence)

        framebuffer = vulkan.Framebuffer(device, {
            renderPass = pass.renderPass
            attachments = [view]
            width = gpu.screen.width
            height = gpu.screen.height
            layers = 1
        })
        swapchain.framebuffers.append(framebuffer)
        # DEP: cbuf, begin of renderpass

    vertex_shader = createShader(device,
        fs.read_file(dir ++ "vertex_shader.spv", "b"))
    fragment_shader = createShader(device,
        fs.read_file(dir ++ "fragment_shader.spv", "b"))
    # DEP: pipeline

    pipeline = gpu.createGraphicsPipeline({
        flags = 0
        stages = [
            {
                stage = "VERTEX_BIT"
                module = vertex_shader
                name = "main"
            },
            {
                stage = "FRAGMENT_BIT"
                module = fragment_shader
                name = "main"
            }
        ]
        vertexInputState = vertex_layout.input
        inputAssemblyState = vertex_layout.assembly
        viewportState = pass.viewport
        rasterizationState = pass.rasterization
        multisampleState = pass.multisample
        colorBlendState = pass.colorBlend
        dynamicState = pass.dynamic
        layout = pipeline_layout
        renderPass = pass.renderPass
        subpass = 0
    })
    # DEP: cbuf

    frame_statistics = []
    last_image = 0
    render = ():
        # This is lazy. It means we can't continue before the previous frame has been submitted.
        # Need to check with performance counter later, whether this is sufficient
        if swapchain.fences[last_image].getStatus().NOT_READY
            return null
        current_image = device.acquireNextImage(swapchain, 0xFFFFFFFFFFFFFFFF, swapchain.image_acquired)
        frame_begin = time()
        device.resetFences([swapchain.fences[current_image]])

        cbuf.begin({flags = "ONE_TIME_SUBMIT_BIT"})
        cbuf.beginRenderPass({
            renderPass = pass.renderPass
            framebuffer = swapchain.framebuffers[current_image]
            renderArea = gpu.screen.area
            clearValues = [
                {color = {float32 = [
                    sin(time()) * 0.5 + 0.5,
                    sin(time() + 2*pi * 1 / 3) * 0.5 + 0.5,
                    sin(time() + 2*pi * 2 / 3) * 0.5 + 0.5,
                    1.0
                ]}}
            ]
        }, "INLINE")
        cbuf.bindPipeline("GRAPHICS", pipeline)
        cbuf.bindDescriptorSets("GRAPHICS", pipeline_layout, 0, [descset], [])
        cbuf.bindVertexBuffers(0, [vbo.buffer], [0])
        cbuf.draw(6, 1, 0, 0)
        cbuf.endRenderPass()
        cbuf.end()
        gpu.queue.submit([{
            waitSemaphores = [swapchain.image_acquired]
            commandBuffers = [cbuf]
            signalSemaphores = [swapchain.rendering_done]
        }], swapchain.fences[current_image])
        frame_end = time()
        frame_statistics.append(frame_end - frame_begin)

        gpu.queue.present({
            waitSemaphores = [swapchain.rendering_done]
            swapchains = [swapchain.id]
            imageIndices = [current_image]
        })
        last_image := current_image

        if frame_statistics.length >= 1000
            best  = 1.0
            worst = 0.0
            avg   = 0.0
            for stat in frame_statistics
                best = min(best, stat)
                worst = max(worst, stat)
                avg += stat
            avg /= frame_statistics.length
            print("best:", 1/best, "worst:", 1/worst, "avg:", 1/avg)
            frame_statistics := []

    event = ffi.automem(sdl.sdl.Event)
    running = true
    while running
        render()
        sleep(0.001)
        while sdl.sdl.PollEvent(event) != 0
            if event.type == sdl.sdl.QUIT
                running = false

    gpu.queue.waitIdle()
    gpu.device.waitIdle()

    for obj in swapchain.fences ++ swapchain.framebuffers ++ swapchain.views
        obj.destroy()
    descriptor_pool.destroy()
    descset_layout.destroy()
    pipeline.destroy()
    pipeline_layout.destroy()
    vbo.buffer.destroy()
    vbo.buffer.mem.free()
    ubo.buffer.destroy()
    ubo.buffer.mem.free()
    vertex_shader.destroy()
    fragment_shader.destroy()
    pass.renderPass.destroy()
    gpu.destroy()

class GPU
    +init = (self, window):
        self.window = window
        self.instance = vulkan.Instance({
            enabledExtensionNames = window.wsi.required_extensions(
                vulkan.listInstanceExtensions())})
        self.screen = exnihilo();
            width = window.width
            height = window.height
            offset = {x = 0, y = 0}
            extent = {width = width, height = height}
            area = {offset=offset, extent=extent}
            viewport = {x = 0, y = 0,
                width = width, height = height,
                minDepth = 0.0, maxDepth = 1.0}
        self.surface = window.wsi.create_surface(vulkan, self.instance)
        init_device(self, self.instance, self.surface)
        self.swapchain = get_swapchain(self.device, self.surface, self.screen)
        self.mem = GPUMemory(self.device)
        # needed for pipeline creation
        self.pipeline_cache = vulkan.PipelineCache(self.device, {})

    createGraphicsPipeline = (self, options):
        return self.device.createGraphicsPipeline(self.pipeline_cache, options)

    destroy = (self):
        self.pipeline_cache.destroy()
        self.queue.pool.destroy()
        self.swapchain.image_acquired.destroy()
        self.swapchain.rendering_done.destroy()
        self.swapchain.destroy()
        self.device.destroy()
        self.surface.destroy()
        self.instance.destroy()

    default_pass = (self):
        return object();
            viewport = {
                viewports = [self.screen.viewport]
                scissors = [self.screen.area]
            }
            rasterization = {
                polygonMode = "FILL"
                cullMode = 0
                frontFace = "COUNTER_CLOCKWISE"
            }
            multisample = {rasterizationSamples = "1_BIT"}
            colorBlend = {
                logicOpEnable = false
                logicOp = "CLEAR"
                attachments = [{
                    blendEnable = false
                    colorWriteMask = 0xf
                    srcColorBlendFactor = "ZERO"
                    dstColorBlendFactor = "ZERO"
                    colorBlendOp = "ADD"
                    srcAlphaBlendFactor = "ZERO"
                    dstAlphaBlendFactor = "ZERO"
                    alphaBlendOp = "ADD"
                }]
                blendConstants = [0.0, 0.0, 0.0, 0.0]
            }
            dynamic = null


init_device = (self, instance, surface):
    gpu = null
    queueFamilyIndex = null
    for device in instance.listPhysicalDevices()
        prop = device.getProperties()
        i = 0
        for x in device.listQueueFamilyProperties()
            if not device.getSurfaceSupport(i, surface)
                continue
            if x.queueFlags.GRAPHICS_BIT
                #print("Device name:", prop.deviceName.str)
                #print("            ", prop.deviceType)
                queueFamilyIndex = i
                gpu = device
            i += 1
    assert gpu, "Did not find a suitable GPU"

    self.device = vulkan.Device(gpu, {
        enabledExtensionNames = ["VK_KHR_swapchain"]
        queueCreateInfos = [{
            queueFamilyIndex = queueFamilyIndex
            queuePriorities = [1.0]
        }]
    })
    queue = self.device.getQueue(queueFamilyIndex, 0)
    queue.index = queueFamilyIndex # allow later command pool allocations.
    queue.pool = vulkan.CommandPool(self.device, {
        flags = "RESET_COMMAND_BUFFER_BIT" # allow reset on cbuf.
        queueFamilyIndex = queue.index
    })
    self.queue = queue

get_swapchain = (device, surface, screen):
    imageUsage = "COLOR_ATTACHMENT_BIT"
    gpu = device.physicalDevice

    cap = gpu.getSurfaceCapabilities(surface)
    # uint32_t                         minImageCount;
    # uint32_t                         maxImageCount;
    # VkExtent2D                       currentExtent;
    # VkExtent2D                       minImageExtent;
    # VkExtent2D                       maxImageExtent;
    # uint32_t                         maxImageArrayLayers;
    # VkSurfaceTransformFlagsKHR       supportedTransforms;
    # VkSurfaceTransformFlagBitsKHR    currentTransform;
    # VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    if not cap.currentTransform.IDENTITY_BIT_KHR
        print("Surface transform not desired")
        exit(1)
    if not cap.supportedUsageFlags.COLOR_ATTACHMENT_BIT
        print("Surface does not support the desired usage")
        exit(1)

    imageFormat = null
    colorSpace = null
    for prop in gpu.listSurfaceFormats(surface)
        imageFormat = prop.format
        colorSpace = prop.colorSpace
        break

    presentMode = "FIFO_KHR"
    for mode in gpu.listSurfacePresentModes(surface)
        continue

    format = "B8G8R8A8_UNORM" # hack, should enumerate the damn surface caps already.
    # Fourth temporary measure, no idea where this works.
    swapchain = vulkan.Swapchain(device, {
        surface = surface
        minImageCount = 2
        imageFormat = imageFormat
        imageColorSpace = colorSpace
        imageExtent = screen.extent
        imageUsage = imageUsage
        preTransform = "IDENTITY_BIT_KHR" # ?
        compositeAlpha = "OPAQUE_BIT_KHR"
        imageArrayLayers = 1
        imageSharingMode = "EXCLUSIVE"
        #queueFamilyIndexCount = 0
        #pQueueFamilyIndices = null
        presentMode = presentMode
        #oldSwapchain = null
        clipped = true
    })

    return swapchain;
        screen = screen
        images = swapchain.getImages()
        format = format
        surface = surface
        subresource_range = {
            aspectMask = "COLOR_BIT"
            baseMipLevel = 0
            levelCount = 1
            baseArrayLayer = 0
            layerCount = 1
        }
        image_acquired = vulkan.Semaphore(device)
        rendering_done = vulkan.Semaphore(device)

class GPUMemory
    +init = (self, gpu):
        self.gpu = gpu

    createBuffer = (self, size, usage):
        buffer = vulkan.Buffer(self.gpu, {size = size, usage = usage})
        buffer.mem = self.associate(buffer)
        return buffer

    # replace this with proper allocator when it starts to matter.
    associate = (self, obj):
        req = obj.getMemoryRequirements()

        memoryIndex = null
        for memtype in memory_report(self.gpu.physicalDevice).types
            if (memtype.flags.HOST_VISIBLE_BIT and
                1 & (req.memoryTypeBits >> memtype.index) != 0)
                memoryIndex = memtype.index
        assert memoryIndex, "No gpu-visible memory available for this resource"

        #print(req.size, req.alignment, req.memoryTypeBits)
        mem = self.gpu.allocateMemory({
            allocationSize = req.size
            memoryTypeIndex = memoryIndex
        })
        obj.bindMemory(mem, 0)
        obj.offset = 0
        obj.size = req.size
        return mem

memory_report = (gpu): 
    properties = gpu.getMemoryProperties()
    heaps = []
    for i in range(properties.memoryHeapCount)
        memheap = properties.memoryHeaps[i]
        heaps.append(object();
            index = i
            size = memheap.size
            flags = memheap.flags)
    types = []
    for i in range(properties.memoryTypeCount)
        memtype = properties.memoryTypes[i]
        types.append(object();
            index = i
            flags = memtype.propertyFlags
            heap = heaps[memtype.heapIndex])
    return object();
        heaps = heaps
        types = types

createShader = (device, data):
    return vulkan.ShaderModule(device, {
        codeSize = data.length
        pCode = data
    })
