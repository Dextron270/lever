# Builds the stub documentation after module index has been
# generated by the build_module_index.lc -script.

# Expects the module index file is in the doc:// path.
import json, fs, texopic
from texopic import Group, GroupCell, Macro, Segment, Pre

main = (argv):
    force_stub = argv[2 .:]
    module_index_path = path(argv[1])
    module_index = json.read_file(module_index_path)
    doc_dir = module_index_path.dirname

    for key in module_index
        doc_path = path(module_index[key]["path"])
        doc_path = doc_dir ++ doc_path.relpath(path("doc:/"))
        doc_path = doc_path.dirname ++ (doc_path.basename ++ ".text")
        fields = module_index[key]["fields"]
        document = [Segment(Macro("module", [[key]]), [])]
        for name in fields
            document.append( translate_meta( fields[name], [name] ) )

        overwrite = fs.EXCL # aka. no
        if doc_path.to_string() in force_stub
            overwrite = fs.TRUNC # aka. yes, mandatorily.

        try
            fd = fs.open(doc_path, overwrite | fs.CREAT | fs.WRONLY)
            fd.pwrite( texopic.stringify(document).utf8, 0 )
            fd.close()
            print("created", doc_path)
        except EEXIST as it_exists
            print("exists", doc_path)
            
translate_meta = (obj, macro_args...):
    type = obj["type"]
    if type == "interface"
        fields = []
        for field_name in obj["fields"]
            fields.append(
                translate_meta(obj["fields"][field_name], [field_name] ))
        return Group(
            Macro("interface", macro_args),
            [
                GroupCell(null, [
                    Segment(Macro("extends", []), [
                        link_reference(obj["extends"])
                    ]),
                    Segment(Macro("summary", []), [not_documented]),
                    Segment(Macro("status", []), ["volatile"]),
                ] ++ fields)
            ])
    elif type == "function"
        return translate_function(Macro("function", macro_args), obj)
    elif type == "multimethod"
        methods = []
        for method in obj["methods"]
            methods.append(translate_function(
                Macro("method", []),
                method["function"], method["argtypes"]))
        if "default" in obj and obj["default"]
            methods.append(translate_function(
                Macro("default", []),
                obj["default"]))
        return Group(
            Macro("multimethod", macro_args ++ [obj["arity"].to_string()]),
            [
                GroupCell(null, methods ++ [
                    Segment(Macro("summary", []), [not_documented]),
                    Segment(Macro("status", []), ["volatile"]),
                ])
            ])
    elif type == "object"
        data = []
        if "value" in obj
            data.append(Segment(Macro("value", []), [obj["value"]]))
        else
            data.append(Segment(Macro("interface", []),
                    [link_reference(obj["interface"])]))
        return Group(
            Macro("object", macro_args),
            [
                GroupCell(null, data ++ [
                    Segment(Macro("summary", []), [not_documented]),
                    Segment(Macro("status", []), ["volatile"]),
                ])
            ])
    else
        assert false, type

translate_function = (macro, obj, argtypes=[]):
    assert obj["type"] == "function", "not a function"
    args = []
    i = 0
    for arg in obj["args"]
        head = Macro("arg", [[arg["name"]]])
        if i < argtypes.length
            head.args.append([link_reference(argtypes[i])])
        elif "type" in arg
            head.args.append([link_reference(arg["type"])])
        if "default" in arg
            head.name = "optional"
            head.args.append([arg["default"]])
        args.append(Segment(head, [not_documented]))
        i += 1
    if obj.get("is_variadic", false)
        args.append(Segment(Macro("is_variadic", []), []))
    return Group(macro,
        [
            GroupCell(null, [
                Segment(Macro("source", []), [], Pre(json.write_string(obj["loc"]))),
            ] ++ args ++ [
                Segment(Macro("returns", []), [not_documented]),
                Segment(Macro("summary", []), [not_documented]),
                Segment(Macro("status", []), ["volatile"]),
            ])
        ])

not_documented = Macro("TODO", [])

link_reference = (link):
    if not link[0]
        return Macro("ref", [[".".join(link[1.:])]])
    return Macro("ref", [[link[0]], [".".join(link[1.:])]])
