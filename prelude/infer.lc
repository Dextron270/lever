from graph_utils import
    greedy_biclique_decomposition

#TODO: Modify for the new syntax.

# The type inferencer forms a state machine. States have flow
# edges and transitions. Most of this is described in
# Stephen Dolan's MLsub thesis.
datatype State(op, a) = state(
    pol:         Integer,
    heads:       Set(Sink(op, a)), 
    flow:        Set(State(op, a)), 
    transitions: Dict(Parameter, State(op, a)))
method hash, (==): by_reference
attribute method add_flow = (self, other):
    assert self.pol != other.pol as "polarity conflict"
    self.flow.add(other)
    other.flow.add(self)
# The type parameters described in the runtime/objects/common.py
# form the items used in constructing types.
attribute method add_transition = (self, parameter, other):
    assert (parameter.pol >= 0) == (self.pol == other.pol) as
        "polarity conflict"
    self.transitions[parameter].add(other)
    except NoIndex then
        self.transitions[parameter] = set([other])

# Heads are Interface -objects, they are accompanied by
# sink -objects.

# This is where we do not follow Dolan's paper.
# Call sites have main purpose in resolving operators,
# and operators are the main source of constraints. Therefore
# we mostly have sinks and sites on the negative states and
# actual types on positive states.
datatype Site(op, a) = site(
    op: op,
    coerces: Set((a, Integer, a)),
    state: State(op, a),
    expect: a,
    operators: Dict(a, {input: State(op, a), output: State(op, a)}),
    slots: Dict(Integer, Set(a)))
method hash, (==): by_reference
attribute method transfer = (self, fn):
    coerces = set(self.coerces)
    expect = self.expect
    state = fn(self.state)
    operators = dict([])
    slots = copy(self.slots)
    for index, slot in self.operators repeat
        operators[index] = {input:fn(slot.input), output:fn(slot.output)}
    return site(self.op, coerces, state, expect, operators, slots)

datatype Sink(op, a) =
    sink(index: Integer, site: Site(op, a)) | faucet(a)
method hash, (==): by_value

unwrap = (item):
    case item of
    faucet(a) then return a


fresh_state = (pol):
    return state(pol, set([]), set([]), dict([]))

fresh_operator = (state, op, indices, argc):
    coerces = set()
    expect = get_function_header(argc, 0)
    operators = dict()
    slots = dict()
    for index in indices repeat
        slots[index] = set()
    state.heads.add(faucet(expect))
    return site(op, coerces, state, expect, operators, slots)

fresh_port = ():
    input = fresh_state(-1)
    output = fresh_state(+1)
    input.add_flow(output)
    return {input: input, output: output}

fresh_free_port = (graph):
    port = fresh_port()
    graph.add(port.input)
    graph.add(port.output)
    return port

biunify = (pair, visited):
    if pair in visited then
        return
    visited.add(pair)
    p, q = pair
    assert p.pol > q.pol as "polarity conflict"
    for x in p.heads for y in q.heads repeat
        ok = fit_subtype(p, q, x, y, visited)
        assert ok as
            "type error"
    for s in q.flow repeat
        merge(s, p)
    for s in p.flow repeat
        merge(s, q)
    for param, ws in p.transitions repeat
        wu = q.transitions.get(param, dict())
        if param.pol > 0 then
            for s in ws for u in wu repeat
                biunify((s, u), visited)
        else
            for u in wu for s in ws repeat
                biunify((u, s), visited)

fit_subtype = (p, q, x, y, visited):
    case y of
    sink(index, site) then
        inference_coerce(x, q, index, site, visited)
        return true
    faucet(_) then
        return is_subtype(unwrap(x), unwrap(y))

merge = (dst, src):
    assert dst.pol == src.pol as "polarity conflict"
    for head in src.heads repeat
        dst.heads.add(head)
    for state in src.flow repeat
        dst.add_flow(state)
    for param, ws in src.transitions repeat
        dst.transitions[param].update(ws)
        except NoIndex then
            dst.transitions[param] = set(ws)

# inference_coerce is the main element here.

inference_coerce = (head, q, slot_idx, site, visited):
    k = set([set([unwrap(head)])])

    for i in site.slots.keys() repeat
        if i == slot_idx then continue
        n = set()
        for t in site.slots[i] for h in k repeat
            n.add(h.union([t]))
        k = n
    site.slots[slot_idx].add(unwrap(head))

    doms = set()
    for i in site.slots.keys() repeat
        doms.add(get_dom(i))
 
    coercions = set()
    for heads in k repeat
        # In "proper" implementation, unique_coercion and
        # binary_operator may fail, and there may be
        # a default function listed for operation.
        # If implemented, the coercion target should be
        # marked 'default', and operator should be chosen
        # as 'default'.
        c = unique_coercion(heads)
        for i in site.slots.keys() repeat
            if i == slot_idx then
                coercions.add((unwrap(head), i))
            else
                for u in site.slots[i] if u in heads repeat
                    coercions.add((u,i))
        if c in site.operators then
            ports = site.operators[c]
        else
            #print('operator for', c)
            fn = binary_operator(site.op, c, site.expect)
            ports = dict()
            site.operators[c] = ports
            out = fresh_state(+1)
            out.heads.update(fn.heads)
            for e,ws in fn.transitions.items() repeat
                if e in doms then
                    xx = fresh_state(-1)
                    out.add_transition(e, xx)
                    yy = fresh_state(+1)
                    xx.add_flow(yy)
                    rr = fresh_state(-1)
                    for w in ws repeat merge(rr, w)
                    ports[e] = {input:rr, output:yy}
                else
                    out.transitions[e] = ws
            biunify((out, site.state), visited)

        for h,i in coercions if (h,i,c) not in site.coerces repeat
            site.coerces.add((h,i,c))
 
            k = get_coercion_function_type(h, c)
            cf = get_function_header(1, 0)
            assert k.heads == set([faucet(cf)]) as "type error"
            z = fresh_state(-1)
            for w in k.transitions[get_dom(0)] repeat
                merge(z, w)
            z.heads.clear()

            port = ports[get_dom(i)]
            biunify((port.output, z), visited)
            for w in k.transitions[cod] repeat
                biunify((w, port.input), visited)

binary_operator = (op, head, expect):
    # 'op' is the operation being invoked.
    # 'head' is the element we query
    # 'expect' described a prefered format for the thing.
    if op == (+) and head == Integer then
        f = fresh_state(+1)
        f.heads.add(faucet(get_function_header(2, 0)))
        z1 = fresh_state(-1)
        z1.heads.add(faucet(Integer))
        z2 = fresh_state(-1)
        z2.heads.add(faucet(Integer))
        r = fresh_state(+1)
        r.heads.add(faucet(Integer))
        f.add_transition(get_dom(0), z1)
        f.add_transition(get_dom(1), z2)
        f.add_transition(cod, r)
        return f
    assert false as "not implemented"

get_coercion_function_type = (a, b):
    if a == b then
        f = fresh_state(+1)
        f.heads.add(faucet(get_function_header(1, 0)))
        z = fresh_state(-1)
        z.heads.add(faucet(a))
        r = fresh_state(+1)
        r.heads.add(faucet(b))
        for param in a.params() repeat
            p = fresh_state(+param.pol)
            q = fresh_state(-param.pol)
            p.add_flow(q)
            r.add_transition(param, p)
            z.add_transition(param, q)
        f.add_transition(get_dom(0), z)
        f.add_transition(cod, r)
        return f
    assert false as "not implemented"
#     if a == t_int and b == t_rational
#         f = State(+1)
#         f.heads.add(get_function_header(1))
#         z = State(-1)
#         z.heads.add(a)
#         r = State(+1)
#         r.heads.add(b)
#         f.add_transition(dom[0], z)
#         f.add_transition(cod, r)
#         return f

# For subtyping, type variables represent flows,
# this means that only-covariant or only-contravariant
# type variables are superfluous.

to_raw_type = (scheme):
    flow_variables = greedy_biclique_decomposition(
        scheme.generic,
        ((vertex): vertex.flow))
    # recursive types are common and acceptable.
    # 'visi' and 'mapi' ensure that recursive clauses are
    # detected and annotated.
    visi = set()
    mapi = dict()
    rvar_id = 0

    trail = dict()

    s_visit = (state, in_trail):
        assert state in scheme.generic as
            "raw type cannot print schemes with free variables in them"
        if state in visi then
            sym = "rec.r" ++ stringify(rvar_id)
            mapi[state] = "let.r" ++ stringify(rvar_id)
            rvar_id += 1
            return sym
        visi.add(state)

        if state.pol > 0 then
            op = " | "
        else
            op = " & "

        typedecl = []
        for head in state.heads repeat
            case head of
            sink(index, site) then
                name = stringify(site.op)
                if site.state not in visi then
                    line = s_visit(site.state, true)
                    trail[w] = "\n  " ++ name ++ " : " ++ line
            faucet(x) then
                typedecl.append(r_visit(x, state, in_trail))
        for v in flow_variables[state] repeat
            typedecl.append(stringify(v+10, 36))
        if state in mapi then
            typedecl.insert(0, mapi.pop(state))
        visi.discard(state)
        return "(" ++ op.join(typedecl) ++ ")"

    r_visit = (face, state, in_trail):
        px = dict()
        for edge in face.params() repeat
            px[edge] = e_visit(state, edge, in_trail)
        return face.format(px)

    e_visit = (state, edge, in_trail):
        if edge not in state.transitions then
            return "(error?)"
        ws = state.transitions[edge]
        if ws.length == 0 then
            return "()"
        return s_visit(single(ws), in_trail)

    return s_visit(scheme.root, false) ++ "".join(trail.values())

# The generalize recalculates the 'free' state sets in the environment by
# extending it. Then it runs a subset construction that takes everything
# not in 'free' and constructs a new graph. 'generic' ends up labeling the
# states present in this new sub-graph.
generalize = (root, env):
    recalculate_free = (env):
        case env of
        environ_end then
            return set()
        environ(schemes, locals, parent, env_free) then
            free = recalculate_free(parent)
            # Nodes free in parent do not need to appear in free set
            env_free.difference_update(free)
            visit = (state):
                if state not in free then
                    env_free.add(state)
            # type_env.free fills up while we discover new states.
            for state in env_free repeat
                for w in state.flow repeat visit(w)
                for edge, ws in state.transitions
                for w in ws repeat visit(w)

            free.update(env_free)
            return free

    free = recalculate_free(env)

    subsets = dict()    # : {Set(Node) : Node}
    membership = dict() # : {Node : Set(Node)}

    reduce_site_port = (port):
        return reduce_subset(port.pol, set([port]))
    reduce_subset = (pol, subset):
        if subset in subsets then
            return subsets[subset]
        s = fresh_state(pol)
        subsets[subset] = s
        transitions = dict()
        for n in subset repeat
            assert n not in free as "bug: subset must not contain free states"
            for head in n.heads repeat
                case head of
                sink(index, site) then
                    n_site = site.transfer(reduce_site_port)
                    s.heads.add(sink(index, n_site))
                faucet(_) then
                    s.heads.add(head)
            membership[n].append(s)
            except NoIndex then
                membership[n] = [s]
            for edge, ws in n.transitions
            for w in ws repeat
                transitions[edge].add(w)
                except NoIndex then
                    transitions[edge] = set([w])

        for edge, ws in transitions repeat
            extern = set()
            for w in ws if w in free repeat
                extern.add(w)
            ws.difference_update(extern)
            s.transitions[edge] = set([reduce_subset(pol*edge.pol, ws)]) | extern
        return s

    if root in free then
        return {generic:set(), root:root}
    root = reduce_subset(root.pol, set([root]))
    for state, ss in membership repeat
        if state.pol > 0 then continue
        for w in state.flow repeat
            assert w not in free as "bug: free state that is not marked free"
            qq = membership.get(w, [])
            for s in ss for q in qq repeat
                s.add_flow(q)
    return {generic:set(subsets.values()), root:root}

instantiate_type = (scheme):
    mapping = dict()
    copy_state = (n):
        if n not in scheme.generic then return n
        return mapping[n]
        except KeyError then
            m = fresh_state(n.pol)
            mapping[n] = m
            for head in n.heads repeat
                case head of
                sink(index, site) then
                    n_site = site.transfer(reduce_site_port)
                    s.heads.add(sink(index, n_site))
                faucet(_) then
                    s.heads.add(head)
            for w in n.flow repeat
                m.flow.add(copy_state(w))
            for edge, ws in n.transitions repeat
                for w in ws repeat
                    m.add_transition(edge, copy_state(w))
            return m
    root = copy_state(scheme.root)
    return {root: root}


datatype Env(op, a) = environ(
    schemes: Dict(String, {generic: Set(State(op, a)), root: State(op, a)}),
    locals: Dict(String, {input: State(op,a), output: State(op, a)}),
    parent: Env(op, a),
    free: Set(State(op, a))) | environ_end
method getitem = (env, name):
    case env of
    environ(schemes, locals, parent, free) then
        return schemes[name]
        except NoIndex then
            return parent[name]
    environ_end then
        return dict()[name]

inference_function = (fn, env, visited):
    env = environ(dict(), dict(), env, set())
    head = face(fn)
    info = inspect(fn)
    out = fresh_state(+1)
    out.heads.add(faucet(head))
    i = 0
    for arg in info.args repeat
        port = fresh_port()
        out.add_transition(get_dom(i), port.input)
        slot = inference_slot(arg['slot'], env, visited)
        slot.set(port.output)
        i += 1
    retval = inference_program(info.body, env, visited)
    out.add_transition(cod, retval)
    return out

inference_program = (body, env, visited):
    result = fresh_port()
    for stmt in body repeat
        case stmt['type'] of
        "return" then
            value = stmt['value']
            value = inference_expr(value, env, visited)
            biunify((value, result.input), visited)
        "assign" then
            slot = inference_slot(stmt['slot'], env, visited)
            value = inference_expr(stmt['value'], env, visited)
            slot.set(value)
        else
            inference_expr(stmt, env, visited)
    return result.output

inference_expr = (a, env, visited):
    case a['type'] of
    "literal" then
        result = fresh_state(+1)
        case a['kind'] of
        "string" then
            result.heads.add(faucet(String))
        "integer" then
            result.heads.add(faucet(Integer))
        else
            assert false as "missing inference for literal"
        return result
    "slot" then
        return inference_slot(a, env, visited).get()
    "call" then
        callee = inference_expr(a['callee'], env, visited)

        callsite = fresh_state(-1)
        callsite.heads.add(faucet(get_function_header(a['args'].length, 0)))
        i = 0
        for arg in a['args'] repeat
            arg = inference_expr(arg, env, visited)
            callsite.add_transition(get_dom(i), arg)
            i += 1
        result = fresh_port()
        callsite.add_transition(cod, result.input)
        biunify((callee, callsite), visited)
        return result.output
    else
        print(a['type'], "missing")
        assert false as "missing inference for expression"

inference_slot = (a, env, visited):
    case a['kind'] of
    "local" then
        key = 'local' ++ stringify(a['index'])
        port = env.schemes[key]
        except NoIndex then
            port = fresh_free_port(env.free)
            env.schemes[key] = port
        return {
            set: ((a): biunify((a, port.input), visited)),
            get: ((): return port.output) }
    "global" then
        name = a['name']
        return {
            set: ((a): assert false as "not supported"),
            get: (():
                if name == "+" then
                    site = fresh_state(-1)
                    op_site = fresh_operator(site, (+), [0,1], 2)
                    sink0 = fresh_port()
                    sink0.input.heads.add(sink(0, op_site))
                    sink1 = fresh_port()
                    sink1.input.heads.add(sink(1, op_site))
                    result = fresh_port()
                    site.add_transition(get_dom(0), sink0.output)
                    site.add_transition(get_dom(1), sink1.output)
                    site.add_transition(cod, result.input)

                    f = fresh_state(+1)
                    f.heads.add(faucet(face((+))))
                    f.add_transition(get_dom(0), sink0.input)
                    f.add_transition(get_dom(1), sink1.input)
                    f.add_transition(cod, result.output)
                    return f
                assert false as "not supported")
            }
    else
        print(a['kind'], "missing")
        assert false as "missing inference for expression"



foo = ():
    return 1 + 5

env = environ(dict(), dict(), environ_end, set())
visited = set()

out = inference_function(foo, env, visited)
out_scheme = generalize(out, env)
print(to_raw_type(out_scheme))

#operator format [0]
#method List = (a, d):
#    if d == 0 then return "[...]"
#    items = generator
#        for item in a repeat yield format(item, d-1)
#    return "[" ++ ", ".join(items) ++ "]"
#        
#method Dict = (a, d):
#    if d == 0 then return "dict([...])"
#    items = generator
#        for key, value in a.items() repeat
#            yield "(" ++ format(key, d-1) ++ "," ++ format(value, d-1) ++ ")"
#    return "dict([" ++ ", ".join(items) ++ "])"
#
#method Bool = (a, d):
#    return stringify(a)
#
#method Integer = (a, d):
#    return stringify(a)
#
#method String = (a, d):
#    # Yes, should escape the string first...
#    return '"' ++ stringify(a) ++ '"'
#    
#method * = (a, d):
#    return 'some item'
#
#f = inspect(greedy_biclique_decomposition)
#for item in f.body repeat
#    print(format(item, 1))

test1 = fresh_state(+1)
test1.heads.add(faucet(Integer))
test1_scheme = {
    generic: set([test1]),
    root:    test1 }
print(to_raw_type(test1_scheme))

test2_generic = set()
test2 = fresh_state(+1)
fn = face(greedy_biclique_decomposition)
test2.heads.add(faucet(fn))
for param in fn.params() repeat
    st = fresh_state(param.pol)
    test2.add_transition(param, st)
    test2_generic.add(st)
test2_generic.add(test2)
test2_scheme = {
    generic: test2_generic,
    root:    test2 }
print(to_raw_type(test2_scheme))

test3_generic = set()
test3 = fresh_state(+1)
test3.heads.add(faucet(List))
for param in List.params() repeat
    st = fresh_state(param.pol)
    test3.add_transition(param, st)
    test3_generic.add(st)
test3_generic.add(test3)
test3_scheme = {
    generic: test3_generic,
    root:    test3 }
print(to_raw_type(test3_scheme))
