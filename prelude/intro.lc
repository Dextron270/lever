#name = input('what is your name? ')
#print("hello", name)

bind line as ParserState

test_coeffects = ():
    print("current line:", line)
    state.line += 1
    print("current line:", line)
    state.line += 10
    print("current line:", line)
    state.line = 4
    print("current line:", line)

state = {!line: 1}

# this operation is a bit cumbersome now.
call_with_coeffects(test_coeffects,
    [(ParserState, state)])
print("line afterwards:", state.line)

#test = ():
#    x = 0
#    while x < 15 repeat
#        print(x)
#        x += 1
#
#    x = 0
#    while x < 15 repeat
#        print(x)
#        x (jittery_op)= 1
#
#jittery_op = (a, b):
#    if a & 1 == 1 then
#        return a + b * -1
#    else
#        return a + b * +3
#
#test()
#
## I just introduced eq/hash on tuples
#print((2,3) == (2,3))
#
## and a syntax for lists. These are out of the way
## when they're needed.
#list_item = [1,2,3]
#print("list length", list_item.length)
#print("first item",  list_item[0])
#
#slot_5 = slot(5)
#
#print("a weird necessity", *slot_5)
#
#*slot_5 = 10
#
#print("you can set its value", *slot_5)
#
#print("first item in range", range(10) ==> *slot_5)
#for x in *slot_5 repeat
#    print("next", x)
