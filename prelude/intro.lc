from graph_utils import
    greedy_biclique_decomposition

# The type inferencer forms a state machine. States have flow
# edges and transitions. Most of this is described in
# Stephen Dolan's MLsub thesis.
datatype State(a) = state(
    pol:         Integer,
    heads:       Set(a), 
    flow:        Set(State(a)), 
    transitions: Dict(Parameter, State(a)))
method hash, (==): by_reference
attribute method add_flow = (self, other):
    assert self.pol != other.pol as "polarity conflict"
    self.flow.add(other)
    other.flow.add(self)
# The type parameters described in the runtime/objects/common.py
# form the items used in constructing types.
attribute method add_transition = (self, parameter, other):
    assert (parameter.pol >= 0) == (self.pol == other.pol) as
        "polarity conflict"
    self.transitions[parameter].add(other)
    except NoIndex then
        self.transitions[parameter] = set([other])

# Heads are Interface -objects, they are accompanied by
# sink -objects.

# This is where we do not follow Dolan's paper.
# Call sites have main purpose in resolving operators,
# and operators are the main source of constraints. Therefore
# we mostly have sinks and sites on the negative states and
# actual types on positive states.
datatype Site(op, a) = site(
    op: op,
    coerces: Set((a, Integer, a)),
    param: Parameter,
    expect: a,
    operators: Dict(a, {input: State(a), output: State(a)}),
    slots: Dict(Integer, Set(a)))
method hash, (==): by_reference
attribute method transfer = (self, fn):
    coerces = set(self.coerces)
    expect = self.expect
    param = parameter(+1)
    operators = dict([])
    slots = copy(self.slots)
    for index, slot in self.operators repeat
        operators[index] = {input:fn(slot.input), output:fn(slot.output)}
    return site(self.op, coerces, expect, param, operators, slots)

datatype Sink(op, a) = sink(index: Integer, site: Site(op, a))
method hash, (==): by_value
    
fresh_state = (pol):
    return state(pol, set([]), set([]), dict([]))

fresh_operator = (op, indices, argc):
    coerces = set()
    expect = get_function_header(argc)
    param = parameter(+1)
    operators = dict()
    slots = dict()
    for index in indices repeat
        slots[index] = set()
    return site(op, coerces, expect, param, operators, slots)

fresh_port = ():
    input = fresh_state(-1)
    output = fresh_state(+1)
    input.add_flow(output)
    return {input, output}

fresh_free_port = (graph):
    port = fresh_port()
    graph.add(port.input)
    graph.add(port.output)
    return port

biunify = (pair, visited):
    if pair in visited then
        return
    visited.add(pair)
    p, q = pair
    assert p.pol > q.pol as "polarity conflict"
    for x in p.heads for y in q.heads repeat
        assert fit_subtype(p, q, x, y, visited) as
            "type error"
    for s in q.flow repeat
        merge(s, p)
    for s in p.flow repeat
        merge(s, q)
    for param, ws in p.transitions repeat
        wu = q.transitions.get(param, dict())
        if param.pol > 0 then
            for s in ws for u in wu repeat
                biunify((s, u), visited)
        else
            for u in wu for s in ws repeat
                biunify((u, s), visited)

fit_subtype = (p, q, x, y, visited):
    if x == y then
        return true
    #else if y --> sink(index, site) then
    #    inference_coerce(x, q, index, site, visited)
    #    return true
    else
        return false

merge = (dst, src):
    assert dst.pol == src.pol as "polarity conflict"
    for head in src.heads repeat
        dst.heads.add(head)
    for state in src.flow repeat
        dst.add_flow(state)
    for param, ws in src.transitions repeat
        dst.transitions[param].update(ws)
        except NoIndex then
            dst.transitions[param] = set(ws)

# For subtyping, type variables represent flows,
# this means that only-covariant or only-contravariant
# type variables are superfluous.

to_raw_type = (scheme):
    flow_variables = greedy_biclique_decomposition(
        scheme.generic,
        ((vertex): vertex.flow))
    # recursive types are common and acceptable.
    # 'visi' and 'mapi' ensure that recursive clauses are
    # detected and annotated.
    visi = set()
    mapi = dict()
    rvar_id = 0

    trail = dict()

    s_visit = (state, in_trail):
        assert state in scheme.generic as
            "raw type cannot print schemes with free variables in them"
        if state in visi then
            sym = "rec.r" ++ stringify(rvar_id)
            mapi[state] = "let.r" ++ stringify(rvar_id)
            rvar_id += 1
            return sym
        visi.add(state)

        if state.pol > 0 then
            op = " | "
        else
            op = " & "

        typedecl = []
        for head in state.heads repeat
            # TODO: Sink headers should get a specific treatment.
#            if isinstance(head, types.SinkHeader)
#                name = repr(head.site.op)
#                w = k_visit(state, head.site.edge)
#                if w not in visi
#                    line = s_visit(w, true)
#                    trail[w] = "\n  " ++ name ++ " : " ++ line
#                if name not in typedecl
#                    typedecl.append(name)
#                continue
            typedecl.append(r_visit(head, state, in_trail))
        for v in flow_variables[state] repeat
            typedecl.append(stringify(v+10, 36))
        if state in mapi then
            typedecl.insert(0, mapi.pop(state))
        visi.discard(state)
        return "(" ++ op.join(typedecl) ++ ")"

    r_visit = (head, state, in_trail):
        px = dict()
        for edge in head.params() repeat
            px[edge] = e_visit(state, edge, in_trail)
        return head.format(px)

    e_visit = (state, edge, in_trail):
        if edge not in state.transitions then
            return "(error?)"
        ws = state.transitions[edge]
        if ws.length == 0 then
            return "()"
        return s_visit(single(ws), in_trail)

    k_visit = (state, edge):
        assert false as "not implemented"

    return s_visit(scheme.root, false) ++ "".join(trail.values())

#operator format [0]
#method List = (a, d):
#    if d == 0 then return "[...]"
#    items = generator
#        for item in a repeat yield format(item, d-1)
#    return "[" ++ ", ".join(items) ++ "]"
#        
#method Dict = (a, d):
#    if d == 0 then return "dict([...])"
#    items = generator
#        for key, value in a.items() repeat
#            yield "(" ++ format(key, d-1) ++ "," ++ format(value, d-1) ++ ")"
#    return "dict([" ++ ", ".join(items) ++ "])"
#
#method Bool = (a, d):
#    return stringify(a)
#
#method Integer = (a, d):
#    return stringify(a)
#
#method String = (a, d):
#    # Yes, should escape the string first...
#    return '"' ++ stringify(a) ++ '"'
#    
#method * = (a, d):
#    return 'some item'
#
#f = inspect(greedy_biclique_decomposition)
#for item in f.body repeat
#    print(format(item, 1))


#get_function_header(argc, vari, opt)

test1 = fresh_state(+1)
test1.heads.add(Integer)
test1_scheme = {
    generic: set([test1]),
    root:    test1 }
print(to_raw_type(test1_scheme))

test2_generic = set()
test2 = fresh_state(+1)
fn = face(greedy_biclique_decomposition)
test2.heads.add(fn)
for param in fn.params() repeat
    st = fresh_state(param.pol)
    test2.add_transition(param, st)
    test2_generic.add(st)
test2_generic.add(test2)
test2_scheme = {
    generic: test2_generic,
    root:    test2 }
print(to_raw_type(test2_scheme))

test3_generic = set()
test3 = fresh_state(+1)
test3.heads.add(List)
for param in List.params() repeat
    st = fresh_state(param.pol)
    test3.add_transition(param, st)
    test3_generic.add(st)
test3_generic.add(test3)
test3_scheme = {
    generic: test3_generic,
    root:    test3 }
print(to_raw_type(test3_scheme))
