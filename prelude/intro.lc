from graph_utils import
    greedy_biclique_decomposition

# The type inferencer forms a state machine. States have flow
# edges and transitions. Most of this is described in
# Stephen Dolan's MLsub thesis.
datatype State(a) = state(
    pol:         Integer,
    heads:       Set(a), 
    flow:        Set(State(a)), 
    transitions: Dict(Parameter, State(a)))
method hash, (==): by_reference
attribute method add_flow = (self, other):
    assert self.pol != other.pol as "polarity conflict"
    self.flow.add(other)
    other.flow.add(self)
# The type parameters described in the runtime/objects/common.py
# form the items used in constructing types.
attribute method add_transition = (self, parameter, other):
    assert (parameter.pol >= 0) == (self.pol == other.pol) as
        "polarity conflict"
    self.transitions[parameter].add(other)
    except NoIndex then
        self.transitions[parameter] = set([other])

# Heads are Interface -objects, they are accompanied by
# sink -objects.

# This is where we do not follow Dolan's paper.
# Call sites have main purpose in resolving operators,
# and operators are the main source of constraints. Therefore
# we mostly have sinks and sites on the negative states and
# actual types on positive states.
datatype Site(op, a) = site(
    op: op,
    coerces: Set((a, Integer, a)),
    param: Parameter,
    expect: a,
    operators: Dict(a, {input: State(a), output: State(a)}),
    slots: Dict(Integer, Set(a)))
method hash, (==): by_reference
attribute method transfer = (self, fn):
    coerces = set(self.coerces)
    expect = self.expect
    param = parameter(+1)
    operators = dict([])
    slots = copy(self.slots)
    for index, slot in self.operators repeat
        operators[index] = {input:fn(slot.input), output:fn(slot.output)}
    return site(self.op, coerces, expect, param, operators, slots)

datatype Sink(op, a) = sink(index: Integer, site: Site(op, a))
method hash, (==): by_value
    
fresh_state = (pol):
    return state(pol, set([]), set([]), dict([]))

fresh_operator = (op, indices, argc):
    coerces = set()
    expect = get_function_header(argc)
    param = parameter(+1)
    operators = dict()
    slots = dict()
    for index in indices repeat
        slots[index] = set()
    return site(op, coerces, expect, param, operators, slots)

fresh_port = ():
    input = fresh_state(-1)
    output = fresh_state(+1)
    input.add_flow(output)
    return {input, output}

fresh_free_port = (graph):
    port = fresh_port()
    graph.add(port.input)
    graph.add(port.output)
    return port

biunify = (pair, visited):
    if pair in visited then
        return
    visited.add(pair)
    p, q = pair
    assert p.pol > q.pol as "polarity conflict"
    for x in p.heads for y in q.heads repeat
        assert fit_subtype(p, q, x, y, visited) as
            "type error"
    for s in q.flow repeat
        merge(s, p)
    for s in p.flow repeat
        merge(s, q)
    for param, ws in p.transitions repeat
        wu = q.transitions.get(param, dict())
        if param.pol > 0 then
            for s in ws for u in wu repeat
                biunify((s, u), visited)
        else
            for u in wu for s in ws repeat
                biunify((u, s), visited)

fit_subtype = (p, q, x, y, visited):
    if x == y then
        return true
    #else if y --> sink(index, site) then
    #    inference_coerce(x, q, index, site, visited)
    #    return true
    else
        return false

merge = (dst, src):
    assert dst.pol == src.pol as "polarity conflict"
    for head in src.heads repeat
        dst.heads.add(head)
    for state in src.flow repeat
        dst.add_flow(state)
    for param, ws in src.transitions repeat
        dst.transitions[param].update(ws)
        except NoIndex then
            dst.transitions[param] = set(ws)

# For subtyping, type variables represent flows,
# this means that only-covariant or only-contravariant
# type variables are superfluous.

to_raw_type = (scheme):
    flow_variables = greedy_biclique_decomposition(
        scheme.generic,
        ((vertex): vertex.flow))
    # recursive types are common and acceptable.
    # 'visi' and 'mapi' ensure that recursive clauses are
    # detected and annotated.
    visi = set()
    mapi = dict()
    rvar_id = 0

    trail = dict()

    s_visit = (state, in_trail):
        assert state in scheme.generic as
            "raw type cannot print schemes with free variables in them"
        if state in visi then
            sym = "rec.r" ++ stringify(rvar_id)
            mapi[state] = "let.r" ++ stringify(rvar_id)
            rvar_id += 1
            return sym
        visi.add(state)

        if state.pol > 0 then
            operator = " | "
        else
            operator = " & "

        typedecl = []
        for head in state.heads repeat
            # TODO: Sink headers should get a specific treatment.
#            if isinstance(head, types.SinkHeader)
#                name = repr(head.site.op)
#                w = k_visit(state, head.site.edge)
#                if w not in visi
#                    line = s_visit(w, true)
#                    trail[w] = "\n  " ++ name ++ " : " ++ line
#                if name not in typedecl
#                    typedecl.append(name)
#                continue
            typedecl.append(r_visit(head, state, in_trail))
        for v in flow_variables[state] repeat
            typedecl.append(stringify(v+10, 36))
        if state in mapi then
            typedecl.insert(0, mapi.pop(state))
        visi.discard(state)
        print(typedecl)
        print(operator)
        print(operator.join(typedecl))
        return "(" ++ operator.join(typedecl) ++ ")"

    r_visit = (head, state, in_trail):
        px = dict()
        for edge in head.params() repeat
            px[edge] = e_visit(state, edge, in_trail)
        print('CRASH')
        return head.format(px)

    e_visit = (state, edge, in_trail):
        w = k_visit(state, edge)
        return s_visit(w, in_trail)

    k_visit = (state, edge):
        if edge not in state.transitions then
            return "(error?)"
        ws = state.transitions[edge]
        if ws.length == 0 then
            return "()"
        return single(ws)

    return s_visit(scheme.root, false) # ++ "".join(trail.values())

#get_function_header(argc, vari, opt)

test1 = fresh_state(+1)
test1.heads.add(Integer)
test1_scheme = {
    generic: set([test1]),
    root:    test1 }

print(to_raw_type(test1_scheme))

#test1 = state(+1, set([]), set([]), dict([]))
#test2 = state(-1, set([]), set([]), dict([]))
#test1.add_flow(test2)
#
#test3 = fresh_state(+1)
#fn = face(graph_utils.greedy_biclique_decomposition)
#test3.heads.add(fn)
#for param in fn.params() repeat
#    test3.add_transition(param, fresh_state(param.pol))
