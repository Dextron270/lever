<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta
  content="width=device-width, initial-scale=1"
  name="viewport"/>
<title>Lever manual: technical overview</title><link
  rel="stylesheet"
  href="../../stylesheet.css">
<!-- Generated from 'doc/tech_overview.text' in github.com/cheery/lever --></head><body><ul
  class="nav"><li><a href="../../"><img
  src="../../logo.png"
  alt="LEVER">
</a></li><li><a
  href="https://github.com/cheery/lever/"
  class="nav_button">repository</a></li><li><a
  href="../../index.html#download"
  class="nav_button">download</a></li><li><a
  href="./"
  class="nav_button">documentation index</a></li></ul><article><h1
  class="embed-header">Manual: technical overview</h1><p>Explains the
project structure. Describes how the runtime ticks. </p><p>Here we
explain what is in the github repository. It is also explained what is
in the runtime when it loads up a program. </p><a
  id="toc-link"
  href="#-toc">Table of contents â†‘</a><fieldset class="toc"
  id="-toc"><legend>Table of contents</legend><div>01. <a
  href="#01">Project hierarchy </a></div><div>01.1. <a
  href="#01.1">app -directory </a></div><div>01.2. <a
  href="#01.2">benchmarks -directory </a></div><div>01.3. <a
  href="#01.3">compiler -directory </a></div><div>01.4. <a
  href="#01.4">doc -directory </a></div><div>01.5. <a
  href="#01.5">documentation_considerations.tex
</a></div><div>01.6. <a href="#01.6">headers -directory
</a></div><div>01.7. <a href="#01.7">internal_documentation.txt
</a></div><div>01.8. <a href="#01.8">lever, lever.exe
</a></div><div>01.9. <a href="#01.9">lever-0.9.0.grammar
</a></div><div>01.10. <a href="#01.10">lever.py
</a></div><div>01.11. <a href="#01.11">lib -directory
</a></div><div>01.12. <a href="#01.12">LICENSE.md
</a></div><div>01.13. <a href="#01.13">local -directory
</a></div><div>01.14. <a href="#01.14">marketing -directory
</a></div><div>01.15. <a href="#01.15">native_considerations.txt
</a></div><div>01.16. <a href="#01.16">performance.text
</a></div><div>01.17. <a href="#01.17">README.md
</a></div><div>01.18. <a href="#01.18">runtime -directory
</a></div><div>01.19. <a href="#01.19">sample.lc
</a></div><div>01.20. <a href="#01.20">samples -directory
</a></div><div>01.21. <a href="#01.21">semantics_documentation.txt
</a></div><div>01.22. <a href="#01.22">setup.py
</a></div><div>01.23. <a href="#01.23">test.py
</a></div><div>01.24. <a href="#01.24">tests -directory
</a></div><div>01.25. <a href="#01.25">tool_ideas.text
</a></div><div>01.26. <a href="#01.26">tools -directory
</a></div><div>01.27. <a href="#01.27">VERSION
</a></div><div>01.28. <a href="#01.28">website_considerations.txt
</a></div><div>01.29. <a href="#01.29">win32_extras -directory
</a></div><div>01.30. <a href="#01.30">www -directory
</a></div><div>02. <a href="#02">Documentation effort
</a></div><div>03. <a href="#03">Setup script functionality
</a></div><div>04. <a href="#04">When Lever starts
</a></div><div>05. <a href="#05">Runtime structure
</a></div></fieldset><script src="../../toc-helper.js"></script><h2
  id="01">01. Project hierarchy
</h2><p></p><pre>app
benchmarks
compiler
doc
documentation_considerations.tex
headers
internal_documentation.txt
lever
lever-0.9.0.grammar
lever.py
lib
LICENSE.md
local
marketing
native_considerations.txt
performance.text
README.md
runtime
sample.lc
samples
semantics_documentation.txt
setup.py
test.py
tests
tool_ideas.text
tools
VERSION
website_considerations.txt
win32_extras
www
</pre><h3
  id="01.1">01.1. app -directory </h3><p>Contains the application
script that is run when the lever executable is run without arguments.
</p><h3 id="01.2">01.2. benchmarks -directory </h3><p>Some programs
that have been used to optimize the runtime. </p><h3
  id="01.3">01.3. compiler -directory </h3><p>Contains the
bootstrapping compiler to bootstrap the another one in the
lib&#x2F;compiler.lc </p><h3 id="01.4">01.4. doc -directory
</h3><p>Contains nearly all the documentation for the project. The
documentation is intended to be readable by the runtime so it&#x27;s
been written in a weird language. </p><h3
  id="01.5">01.5. documentation_considerations.tex </h3><p>Some old
discussion about solving the documentation problems in the project.
They are still not entirely solved, but the ideas in this file drove
them further. Should be merged with the rest of the documentation.
</p><h3 id="01.6">01.6. headers -directory </h3><p>A slightly old
directory that contains C FFI files that are used by libraries. They
could also sit in the lib&#x2F; -directory by now, but this directory
was there before the module system had improved to provide a method to
load these json files from the lib. </p><h3
  id="01.7">01.7. internal_documentation.txt </h3><p>A very early form
of documentation about the runtime -directory. Should be also merged
with the main documentation. </p><h3 id="01.8">01.8. lever, lever.exe
</h3><p>The executable binary that is generated from the runtime
directory. </p><h3 id="01.9">01.9. lever-0.9.0.grammar </h3><p>The
machine-readable grammar file. Used by both the compiler&#x2F; and
lib&#x2F;compiler.lc. A form of an attribute grammar. </p><h3
  id="01.10">01.10. lever.py </h3><p>A script to run lever runtime
interpreted by Python. Barely ever used these days because it&#x27;s
so slow method to run the code. </p><h3 id="01.11">01.11. lib
-directory </h3><p>A comprehensive set of modules written in Lever
meant to become a standard library. It is distributed along the
runtime. </p><h3 id="01.12">01.12. LICENSE.md </h3><p>License file for
the repository. It&#x27;s a MIT license. </p><h3
  id="01.13">01.13. local -directory </h3><p>This directory gets
created by the setup.py -script. It contains third party dependencies
that are required along the binary. </p><p>Doing this ensures that we
have recent versions about the libraries that we are using, and makes
it easier to compile the project on Windows. </p><h3
  id="01.14">01.14. marketing -directory </h3><p>Supposed to contain
press kits and such, but right now contains only an one image. </p><h3
  id="01.15">01.15. native_considerations.txt </h3><p>Some remarks and
notes about compiling for native machine code. Should be merged into
the rest of the documentation. </p><h3
  id="01.16">01.16. performance.text </h3><p>Stub for accessibility.
The contents have been moved into: <a
  href="https://leverlanguage.com/doc/latest/performance.html">https:&#x2F;&#x2F;leverlanguage.com&#x2F;doc&#x2F;latest&#x2F;performance.html</a>
</p><h3 id="01.17">01.17. README.md </h3><p>I&#x27;m not entirely sure
what I should do with this file, but it also contains some
documentation. Maybe it should be slowly merged with the rest of the
documentation. </p><h3 id="01.18">01.18. runtime -directory
</h3><p>The part of the Lever that has to be translated and then
compiled into a executable file. </p><h3 id="01.19">01.19. sample.lc
</h3><p>A kind of a scratch buffer for trying out small things. A
semi-temporary file. </p><h3 id="01.20">01.20. samples -directory
</h3><p>Bundle of old and new sample programs, tests and experiments.
</p><h3 id="01.21">01.21. semantics_documentation.txt </h3><p>An older
file describing semantics of the language in terms of the grammar
declarations. Should be merged into the rest of the documentation.
</p><h3 id="01.22">01.22. setup.py </h3><p>Maintenance script for the
project. Will be described in detail in an another section. </p><h3
  id="01.23">01.23. test.py </h3><p>An old script for running test
script. </p><h3 id="01.24">01.24. tests -directory </h3><p>Outdated
list of tests that was tried some time back when everything barely
worked. </p><h3 id="01.25">01.25. tool_ideas.text </h3><p>Related to
the performance.text discussion. Will be eventually merged in there as
well. </p><h3 id="01.26">01.26. tools -directory </h3><p>Variety of
tools written in Lever and Python. Mostly concerned with html
documentation and machine readable specs. </p><h3
  id="01.27">01.27. VERSION </h3><p>Version number of the lever
release. </p><h3 id="01.28">01.28. website_considerations.txt
</h3><p>Some old discussion on the website contents. </p><h3
  id="01.29">01.29. win32_extras -directory </h3><p>A bundle of extra
binary files needed to run the produced executable on a Windows
system. </p><h3 id="01.30">01.30. www -directory </h3><p>The copy from
the website directory. Mostly generated with a hint of some files that
haven&#x27;t been. </p><h2 id="02">02. Documentation effort
</h2><p>The doc&#x2F; -directory is itself an experiment. Overall the
structure looks like it could work, but the format is not that
desirable. Although the documentation is mostly in the single place
that distributes it where it is needed. It is cleanly and consistently
formatted, relatively easy to write. The format itself has been
lacking in providing machine-assisted tools for updating the
documentation. </p><p>Eventually when the format is changed, the
existing documentation won&#x27;t be removed. It will be automatically
translated into the new format. There are plans for a binary format of
one kind. Designed to be easy to edit by an editor, have dense
representation for the information and allow a good diff algorithm to
be implemented on the contents. </p><h2 id="03">03. Setup script
functionality </h2><p>When you do &#x27;python setup.py -h&#x27; you
get...
</p><p></p><pre>usage: setup.py [-h]
                {build-local,compile,compile-lib,win32-dist,refresh-docs,stub,update-html-docs}
                ...

positional arguments:
  {build-local,compile,compile-lib,win32-dist,refresh-docs,stub,update-html-docs}
    build-local         Compile the statically linked third party dependencies
                        for Lever
    compile             Compile the lever runtime
    compile-lib         Compile lib&#x2F; contents
    win32-dist          Create win32 distribution
    refresh-docs        Refresh the source index and then update all
                        documentation
    stub                Produce documentation stub for an item in the source
                        index
    update-html-docs    Update HTML documentation

optional arguments:
  -h, --help            show this help message and exit

</pre><p>&#x27;python
setup.py build-local&#x27; downloads and builds the dependencies
needed on Windows. If you don&#x27;t have zlib or libuv or you&#x27;re
unsure whether they&#x27;re new enough on your system, you may want to
run this on Linux as well. </p><p>&#x27;python setup.py compile&#x27;
runs little bit of dependency checking&#x2F;troubleshooting and
retrieves pypy into it&#x27;s own path, so that it would be really
easy to build this project. I&#x27;ve tried to make it sure that the
program does one of: nags, attempts to get the dependencies, lists out
the missing dependencies rather than that it would go into compiling
and fail sometime during the compiling wasting your time.
</p><p>Sometimes there can still be a hitch in the compiling, but
it&#x27;s not the default behavior here. </p><p>&#x27;python setup.py
compile-lib&#x27; is run implicitly after compile. It uses the python
compiler to compile bytecode for as many files in lib&#x2F; as it can.
Because it is slightly out of sync it won&#x27;t succeed with all of
them, but it should succeed just enough that the lib&#x2F;compiler.lc
is able to run. </p><p>&#x27;python setup.py win32-dist&#x27; some
long time ago this built the 0.8.0 win32 standalone distribution.
Maybe it&#x27;ll build the 0.9.0 standalone at some point!
</p><p>&#x27;python setup.py refresh-docs&#x27; prints the module
index into &#x27;doc&#x2F;source_index.json&#x27;. It probably
doesn&#x27;t work all the time, but when it&#x27;s time to use it
we&#x27;ll fix it. It collects all the modules and functions so that
we can quickly generate documentation stubs for them. </p><p>I
don&#x27;t like yet how this works when it comes to updating the
documentation, so it&#x27;ll change eventually. </p><p>&#x27;python
setup.py update-html-docs&#x27; builds the HTML documentation in the
www&#x2F;. Everything in that directory isn&#x27;t build, but the
stuff that comes from the doc&#x2F; is rewritten. Lets see when it
needs to be improved. </p><h2 id="04">04. When Lever starts
</h2><p>Lever has two modes of startup. If you pass in a script, it
runs that script. If no script is given the interpreter runs the
&#x27;app&#x2F;main.lc&#x27; which provides a read-eval-print-loop.
</p><p>When the runtime starts up, it inserts some initial tasks into
a queue and then starts up an eventloop. The eventloop is provided by
the library libuv. The whole system implements co-operative task
switching with greenlets. </p><p>Thread spawning in Lever is not
complete, but the multiple threads are supported. This means that we
have both in-thread and between-threads concurrency present in our
runtime. I know that this isn&#x27;t potentially very ideal in every
situation. Later, we will probably try to solve some of the problems
with write access control or such. </p><p>After the event loop is
loaded, the runtime sets up a module scope, importing routines, some
basic I&#x2F;O utilities and starts up the main script. Libuv handling
of stdin&#x2F;stdout&#x2F;stderr can be a nuisance quite too often, so
we&#x27;ll have to change some of that eventually. </p><p>The scoping
in Lever does not have an idea of a mutable global space. It can be
illustrated by the following script:
</p><p></p><pre>scope = %&quot;import&quot;.scope # Get the scope of this module.
while scope
    print(scope.local)
    scope = scope.parent
</pre><p>The
&#x27;import&#x27; and .scope within it are ordinary variables that
can be found from the module that is given. They are also not
mandatory in a module, but without them the import clauses do not
work, of course. </p><p>It prints out the following kind of a
hierarchy:
</p><p></p><pre>path(&quot;module&#x27;s directory&quot;)
path(&quot;${lever_path}&#x2F;lib&quot;)
path(&quot;builtin:&#x2F;&quot;)
</pre><p>This
points out where the modules are searched from. These are the
directories assigned for our module scopes and they form a hierarchy.
</p><p>The topmost module scope is always created when the Lever
starts up. It loads modules from the same directory where the starting
script is. </p><p>Currently the &#x27;&#x2F;lib&#x27; scope is also
created at startup. It points out where to search the system libraries
from that have been written in lever. </p><p>The
&#x27;builtin:&#x2F;&#x2F;&#x27; is pointing to the modules
implemented by the runtime. Most of it comes from the
runtime&#x2F;stdlib&#x2F; -directory. The contents of this scope are
immutable. </p><p>Each scope object memoizes the modules that are
already loaded and attempts to fetch the memoized module. Explicit
reload command needs to be called if it is desirable to reload the
module. </p><p>Solving the module system without having mutable
globals was proposed by the maintainer of Python&#x27;s module system.
I think it is nearly just like I want it. </p><p>You can create new
scopes yourself and discard them when you no longer need them. It
makes it very easy to implement a plugin framework for your
application. </p><p>Modules themselves can take a parent module. The
variable is fetched from the parent module if it isn&#x27;t present in
the module itself. The &#x27;base&#x27; module is used as a base by
default, but you can change that too when you introduce a new module
scope. </p><h2 id="05">05. Runtime structure </h2><p>Lever&#x27;s
runtime builds hierarchically. </p><p>On the lowest layer we have
runtime&#x2F;continuations.py and runtime&#x2F;core.py. These parts
define interactions between event loop and continuations, and those
interactions sometimes spread far into the remaining parts of the
runtime because they allow tasks to wait asynchronously. </p><p>The
runtime&#x2F;space&#x2F; -directory describes our object system. It
contains most primitive objects and containers that we happen to have
in the system. </p><p>The runtime&#x2F;base&#x2F; describes the base
module in our system. Although some of the values in that base module
are filled up in all around the runtime&#x2F; -directory. </p><p>The
runtime&#x2F;evaluator&#x2F; contains the interpreter. It is loading
the module from json-like objects that are defined by
&#x27;runtime&#x2F;bon.py&#x27; -module. This is a custom format
specific to Lever and it may need much more work before it is
satisfying enough. </p><p>The runtime&#x2F;stdlib&#x2F; contains the
&#x27;standard modules&#x27; that are defined by the runtime. They
provide functionality that could not be provided otherwise. They are
gathered in the runtime&#x2F;module_resolution.py which defines the
module scopes and import mechanisms. </p><p>The uv_ -prefixed files
are all libuv related helpers and utilities. There is a still mix of
two interfaces there, one that I started with and another iteration of
it. It is in the &#x27;proof of concept&#x27; -phase. Once it matters
a bit more, we should move on to building good I&#x2F;O streaming
primitives around the features of the libuv. Lets hope that we
won&#x27;t depend too much on the kinks of that API. </p><p>The
runtime&#x2F;vectormath.py provides some vector, matrix, quaternion
arithmetic along trigonometric functionality. Some of the operations
there belongs into the stdlib, though I would prefer to provide
&#x27;pi&#x27;, &#x27;tau&#x27;, &#x27;sin&#x27;, &#x27;cos&#x27; so
on.. in the base module because they are very useful functions and
variables. </p><p>pathobj.py is provides a layer to transform windows
paths to POSIX and HTML paths. This is used implicitly in lot of
places of our runtime because it&#x27;s nice if every file path is in
a consistent format. Additionally these paths are all wrapped into
path -object that makes it easy to work on them. On the retrospect the
important thing is consistent path handling, not hiding of
Windows-style paths. We may adjust the design to that direction later
on. </p></article><div style="text-align: center"><span
  style="background-color: #85818e; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #df7120; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #a7341c; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #5c231c; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #a39ea4; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #312334; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #44588e; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #4679b8; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #79bbe8; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #d7d2d7; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #785d9a; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #949e85; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #2e170e; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #7b3c16; width: 1em; height: 1em; display: inline-block">
</span><span
  style="background-color: #c86f31; width: 1em; height: 1em; display: inline-block">
</span></div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-12626354-9', 'auto');
      ga('send', 'pageview');
    </script></body></html>